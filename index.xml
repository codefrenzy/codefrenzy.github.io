<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xml:base="http://annievella.com/">
  <channel>
    <title>Annie Vella</title>
    <link>http://annievella.com/</link>
    <description>Recent content on Annie Vella</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <managingEditor>annie.luxton@gmail.com (Annie Vella)</managingEditor>
    <webMaster>annie.luxton@gmail.com (Annie Vella)</webMaster>
    <copyright>¬© 2023-2026 Annie Vella</copyright>
    <lastBuildDate>Mon, 29 Dec 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://annievella.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Publications</title>
      <link>http://annievella.com/publications/</link>
      <pubDate>Mon, 29 Dec 2025 00:00:00 +0000</pubDate><author>annie.luxton@gmail.com (Annie Vella)</author>
      <guid>http://annievella.com/publications/</guid>
      <description>
      
      
      <![CDATA[<p>Writing has never come naturally to me - I was always a science and maths kid through and through. But many moons ago, my dad convinced me to take English in my final year of high school with words that have stuck with me ever since: <em>&ldquo;There&rsquo;s no point having all that knowledge if you can&rsquo;t communicate it&rdquo;</em>. Through blogging and speaking, I&rsquo;ve been working on that, and slowly but surely, I&rsquo;m being asked to contribute to publications beyond my own site.</p>
<p>Below is a list of publications I&rsquo;ve contributed to.</p>
<p>If you&rsquo;d like me to write for or collaborate on your publication, please feel free to <a href="mailto:annie.luxton@gmail.com">get in touch</a>. I&rsquo;d love to connect!</p>
<h2 id="2025">2025</h2>
<h3 id="papers">Papers</h3>
<ul>
<li><a href="https://dl.acm.org/doi/10.1145/3715003">The Future of AI-Driven Software Engineering</a> (<a href="https://annievella.com/files/acm-transactions-on-software-engineering-and-methodology-2025-the-future-of-ai-driven-software-engineering.pdf">PDF</a>) co-authored with <a href="https://orcid.org/0000-0001-5885-9297">Valerio Terragni</a>, <a href="https://orcid.org/0000-0001-9654-5678">Partha Roop</a> and <a href="https://orcid.org/0000-0003-4092-9706">Kelly Blincoe</a>, published in <a href="https://dl.acm.org/toc/tosem/2025/34/5">ACM Transactions on Software Engineering and Methodology</a> on May 26</li>
</ul>
<h3 id="articles">Articles</h3>
<ul>
<li><a href="https://techwomen.nz/2025/11/10/ai-and-the-new-boundaries-of-technical-work/">AI and the New Boundaries of Technical Work</a> published on <a href="https://techwomen.nz">TechWomen NZ</a> on November 10</li>
</ul>
<h3 id="contributions">Contributions</h3>
<ul>
<li><a href="https://arxiv.org/abs/2511.16092v1">The Future of Development Environments with AI Foundation Models: NII Shonan Meeting 222 Report</a> (<a href="https://annievella.com/files/nii-shonan-meeting-222-2025-the-future-of-development-environments-with-ai-foundation-models.pdf">PDF</a>) - participated as one of 33 experts in this Shonan Meeting discussion in Shonan, Japan, on October 6-9</li>
</ul>
<h2 id="2003">2003</h2>
<h3 id="papers-1">Papers</h3>
<ul>
<li><a href="https://ieeexplore.ieee.org/abstract/document/1260249">Ubiquitous Web-based Programming</a> (<a href="https://annievella.com/files/ieee-symposium-on-hcc-languages-and-environments-2003-ubiquitous-web-based-programming.pdf">PDF</a>) presented at the <a href="https://ieeexplore.ieee.org/servlet/opac?punumber=8908">IEEE Symposium on Human Centric Computing Languages and Environments</a> in Auckland, New Zealand, on October 31</li>
</ul>
]]><![CDATA[<hr><p>Thanks for reading this post via RSS! üëã</p>]]><![CDATA[<a href="mailto:annie.luxton@gmail.com?subject=Publications">Reply to this post by email</a>]]></description>
    </item>
    <item>
      <title>A Whole New World</title>
      <link>http://annievella.com/posts/a-whole-new-world/</link>
      <pubDate>Sun, 30 Nov 2025 00:00:00 +1300</pubDate><author>annie.luxton@gmail.com (Annie Vella)</author>
      <guid>http://annievella.com/posts/a-whole-new-world/</guid>
      <description>
      
      
      <![CDATA[<p>In the years I&rsquo;ve been building software, I&rsquo;ve lived through more than a few waves. My first taste of code was in the mid‚Äë80s, typing BASIC into a Commodore 64 where you couldn&rsquo;t even save your work to a hard drive. In the mid‚Äë90s, scripting in mIRC and hand‚Äërolling simple HTML sites felt cutting edge. The early 2000s were all about desktop apps, then web apps that suddenly got a lot more dynamic - yet for a while, Flash was still the only way to refresh part of a page without the user hammering the browser&rsquo;s refresh button. Then AJAX arrived and changed that.</p>
<p>After that came an explosion of tools and technologies. On the application side, we reached for caches, queues, NoSQL databases, and event streams to make distributed systems possible and keep them performing under load. On the delivery and infrastructure side, DevOps pipelines and automated static analysis tools helped us ship faster, automated testing gave us confidence in what we were releasing, and cloud and infrastructure‚Äëas‚Äëcode let us scale in a far more programmatic way. Mobile in the 2010s brought a whole new set of tools and constraints with it - you had to really think about payloads, because pushing huge amounts of data over mobile networks just wasn&rsquo;t a great idea.</p>
<p>These are the kinds of shifts we point to when we talk about why software engineering is a career where there&rsquo;s <em>always</em> more to learn. New technologies arrive constantly, and if you want to build the right solutions with the tools available today, you have to keep up, experiment, and learn how to put those tools to work in meaningful ways.</p>
<p>What&rsquo;s exciting now is that with Gen AI, we&rsquo;ve added a whole new kind of component to that toolkit: the LLM. We can weave it into our systems in all sorts of ways - as a helper inside a feature, as the thing that orchestrates tools and workflows, or as the layer that sits in front of everything and talks to users. By its very nature, though, it&rsquo;s non-deterministic and often unpredictable. That forces us to rethink how we design software end-to-end, from architecture and implementation through to testing, deployment and the way we run these systems in production.</p>
<h2 id="from-deterministic-to-nondeterministic-systems">From deterministic to non‚Äëdeterministic systems</h2>
<p>In a recent <a href="https://www.youtube.com/watch?v=CQmI4XKTa0U">conversation</a> between <a href="https://martinfowler.com/">Martin Fowler</a> and <a href="https://blog.pragmaticengineer.com/">Gergely Orosz</a>, Martin puts his finger on this very point: the importance of the introduction of non-determinism into our systems. He leans on his wife&rsquo;s world of structural engineering, where one must think in terms of <em>tolerances</em> and deliberately build extra capacity into a bridge or a building because materials like wood, concrete and steel all vary. You can never assume two pieces of timber will behave identically. Instead, you learn as much as you can about the materials and then design around that uncertainty. I think he&rsquo;s right that we&rsquo;ll need a similar mindset when we work with non‚Äëdeterministic AI components, understanding the &ldquo;tolerances&rdquo; of that uncertainty and resisting the temptation to skate too close to the edge, especially on the security side.</p>
<p>In my AI Native DevCon talk six months ago, <a href="https://youtu.be/53yziql9h-U?si=2RJpT5Ve05fhHVdt"><em>Am I Still a Software Engineer If I Don&rsquo;t Write the Code?</em></a>, I shared a slide titled &ldquo;New tools, new problems, new solutions&rdquo; to illustrate some of the new problem spaces opening up for us as engineers. Basically, this post zooms in on just one of those boxes: <strong>designing non-deterministic systems</strong>.</p>
<figure class="center"><img src="http://annievella.com/images/new-tools-new-problems-new-solutions.png"
    alt="New tools, new problems, new solutions"><figcaption>
      <p>From my AI Native DevCon talk <a href="https://youtu.be/53yziql9h-U?si=2RJpT5Ve05fhHVdt"><em>Am I Still a Software Engineer If I Don&rsquo;t Write the Code?</em></a> This post focuses on one of these areas: designing non-deterministic systems.</p>
    </figcaption>
</figure>

<h2 id="the-rise-of-the-ai-application-layer">The rise of the AI application layer</h2>
<p>Up until recently, most of my research has focused on what AI is doing to software engineering as a discipline: how it changes the process of building software, what it does to our day‚Äëto‚Äëday experience as engineers, and how it shifts where we spend our time when we have an AI assistant sitting beside us in the IDE. But I&rsquo;m just as intrigued by what it means for the <em>software itself</em>. The kinds of systems we can now build. The architectures we reach for. The new constraints we run into and the new classes of problems we have to solve when a non‚Äëdeterministic component sits in the middle of everything.</p>
<p>That curiosity has led me to focus more on the <strong>AI application layer</strong> - the part of the stack where models, tools and products actually meet real users. And there are strong signals that this focus is well‚Äëplaced. <a href="https://www.andrewng.org/">Andrew Ng</a>, in a recent <a href="https://www.deeplearning.ai/the-batch/issue-329/">Batch</a> editorial, pointed out that while huge amounts of money and attention are flowing into infrastructure and foundation models, the AI application layer is comparatively under‚Äëinvested. There&rsquo;s a lot of value still to be created there, and that value will come from people who know how to design, build and operate these new kinds of systems.z</p>
<p>We&rsquo;re already starting to attach more specific labels to those people - titles like <strong>AI Engineer</strong>, <strong>AI Application Developer</strong>, or <strong>AI Application Architect</strong> - folks who live closer to that layer. But I don&rsquo;t think of that as a separate profession. Just as we once had to learn our way around caches, queues, mobile constraints and cloud tooling, this is simply the next set of tools and patterns we need to get fluent in. We&rsquo;re still software engineers, and these are tools, patterns, and ways of thinking that we&rsquo;ll be better off knowing, whether or not we ever put &ldquo;AI&rdquo; in our job titles.</p>
<p>This post is my working map of the skills and concepts I think matter for software engineers who want to build in this new LLM / agentic paradigm.</p>
<h2 id="how-the-work-shifts">How the work shifts</h2>
<p>Before diving into the detail, it helps to name the kinds of work that shift when you bring LLMs and agents into the mix. There is still solution design and architecture, but instead of just deciding where your service boundaries lie, you&rsquo;re deciding what belongs in deterministic code vs a model, where to introduce retrieval or agents, and how to build in safety and human oversight from the start.</p>
<p>There is still engineering, but more and more it means stitching together models, tools, data stores, workflows and observability into something coherent and operable. A lot of the hard work now is in learning the new tooling and patterns well enough that you can keep systems explainable and debuggable, even when some core components are probabilistic.</p>
<p>And there is still validation, but it looks very different from traditional unit and integration testing. You need new ways to evaluate behaviour over time, catch regressions when models or prompts change, and decide what &ldquo;good enough&rdquo; means for systems that will never be perfectly predictable.</p>
<h2 id="ai-engineering-competency-map">AI Engineering Competency Map</h2>
<p>What follows is a set of skill areas and capabilities you can explore if you want to get serious about building systems with LLMs and agents at their core. This is simply my current view, shaped by what I&rsquo;m reading, what I&rsquo;m building, and what I&rsquo;m seeing across the industry, not a set of hard rules or a checklist to complete. It&rsquo;s deliberately broad, not exhaustive, and almost certain to evolve as the tools, patterns and best practices do.</p>
<h3 id="1-models-providers--core-stack">1. Models, Providers &amp; Core Stack</h3>
<p>Understanding which models exist, what they can do, and the core stack used to work with them.</p>
<h4 id="11-model-providers">1.1 Model providers</h4>
<p>Knowing the major commercial and open model providers and how to integrate their APIs.</p>
<ul>
<li><a href="https://openai.com/">OpenAI</a></li>
<li><a href="https://www.anthropic.com/">Anthropic</a></li>
<li><a href="https://ai.google/">Google</a></li>
<li><a href="https://mistral.ai/">Mistral</a></li>
<li><a href="https://ai.meta.com/">Meta</a></li>
<li><a href="https://groq.com/">Groq</a></li>
</ul>
<h4 id="12-model-capabilities--selection">1.2 Model capabilities &amp; selection</h4>
<p>Choosing appropriate models based on capability, risk and constraints.</p>
<ul>
<li>Reasoning depth vs latency</li>
<li>Text-only vs multimodal</li>
<li>Context length and token limits</li>
<li>Cost profiles and rate limits</li>
<li>Fine-tuned vs general-purpose models</li>
</ul>
<h4 id="13-core-implementation-stack">1.3 Core implementation stack</h4>
<p>Using programming languages and runtimes suitable for AI-enabled backends and agents.</p>
<ul>
<li>Python</li>
<li>TypeScript / JavaScript</li>
<li>Go</li>
<li>C# / .NET</li>
<li>Basic familiarity with async patterns and HTTP APIs</li>
</ul>
<p>‚∏ª</p>
<h3 id="2-knowledge-preparation--retrieval-rag">2. Knowledge Preparation &amp; Retrieval (RAG)</h3>
<p>Preparing data and retrieving it so agents can ground their answers in real information.</p>
<h4 id="21-knowledge-preprocessing">2.1 Knowledge preprocessing</h4>
<p>Transforming messy input into clean, LLM-ready text.</p>
<ul>
<li>PDF to HTML or markdown</li>
<li>OCR and image-to-text</li>
<li>Normalising and cleaning documents</li>
<li>Splitting large files into logical sections</li>
</ul>
<h4 id="22-chunking-strategies">2.2 Chunking strategies</h4>
<p>Breaking documents into useful pieces for retrieval.</p>
<ul>
<li>Fixed-size vs semantic chunking</li>
<li>Sliding windows and overlap</li>
<li>Section- and heading-aware splits</li>
<li>Trade-offs between granularity and context</li>
</ul>
<h4 id="23-embeddings--vector-search">2.3 Embeddings &amp; vector search</h4>
<p>Representing text as vectors and searching semantically.</p>
<ul>
<li>Embedding models and dimensions</li>
<li>Similarity metrics (cosine, dot-product, etc.)</li>
<li>Indexing strategies</li>
<li>Handling updates and re-indexing</li>
</ul>
<h4 id="24-hybrid-retrieval--reranking">2.4 Hybrid retrieval &amp; reranking</h4>
<p>Combining different retrieval techniques to get better results.</p>
<ul>
<li>Keyword search (BM25 or equivalent)</li>
<li>Hybrid search (keyword + vector)</li>
<li>Reranking candidate documents</li>
<li>Balancing recall vs precision</li>
</ul>
<h4 id="25-knowledge-graphs--structured-stores">2.5 Knowledge graphs &amp; structured stores</h4>
<p>Using structured knowledge to support reasoning and answering.</p>
<ul>
<li>Entity and relationship modelling</li>
<li>Graph databases</li>
<li>Joining graph lookups with LLM answers</li>
<li>When to use graphs vs plain RAG</li>
</ul>
<h4 id="26-common-vector-and-search-backends">2.6 Common vector and search backends</h4>
<p>Using production-ready services for retrieval.</p>
<ul>
<li><a href="https://www.pinecone.io/">Pinecone</a></li>
<li><a href="https://weaviate.io/">Weaviate</a></li>
<li><a href="https://azure.microsoft.com/en-us/products/ai-services/ai-search">Azure AI Search / Cognitive Search</a></li>
<li><a href="https://www.elastic.co/enterprise-search/vector-search">Elastic</a> with vector capabilities</li>
<li><a href="https://www.trychroma.com/">Chroma</a> or similar developer-oriented stores</li>
</ul>
<p>‚∏ª</p>
<h3 id="3-context--conversation-management">3. Context &amp; Conversation Management</h3>
<p>Deciding what the model sees, how it sees it, and how to cope with context limits.</p>
<h4 id="31-context-engineering">3.1 Context engineering</h4>
<p>Designing prompts and context to give the model what it needs and nothing it does not.</p>
<ul>
<li>System / user / tool message structure</li>
<li>Injecting retrieved knowledge and constraints</li>
<li>Representing user state and persona</li>
<li>Avoiding irrelevant or distracting information</li>
</ul>
<h4 id="32-context-window-architecture">3.2 Context window architecture</h4>
<p>Managing the limited context window as a resource.</p>
<ul>
<li>Token budgeting across instructions, history and retrieved chunks</li>
<li>Policies for what to keep vs drop</li>
<li>Per-turn context templates</li>
<li>Handling very long workflows or conversations</li>
</ul>
<h4 id="33-compaction-and-summarisation">3.3 Compaction and summarisation</h4>
<p>Compressing history while preserving what matters.</p>
<ul>
<li>Conversation summarisation</li>
<li>State distillation into notes or facts</li>
<li>Periodic ‚Äúsnapshot‚Äù summaries</li>
<li>Trade-offs between fidelity and brevity</li>
</ul>
<h4 id="34-structured-outputs--schemas">3.4 Structured outputs &amp; schemas</h4>
<p>Ensuring outputs are machine-friendly and predictable.</p>
<ul>
<li>JSON and typed schemas</li>
<li>Function / tool call definitions</li>
<li>Validation and error handling</li>
<li>Strategies for recovering from malformed output</li>
</ul>
<p>‚∏ª</p>
<h3 id="4-agent-reasoning--orchestration-patterns">4. Agent Reasoning &amp; Orchestration Patterns</h3>
<p>How agents think, break down work and orchestrate multiple steps or tools.</p>
<h4 id="41-prompt-chaining">4.1 Prompt chaining</h4>
<p>Breaking complex tasks into explicit, ordered LLM calls.</p>
<ul>
<li>Multi-step workflows</li>
<li>Passing intermediate outputs between steps</li>
<li>Designing reusable chains</li>
<li>Handling failure at intermediate steps</li>
</ul>
<h4 id="42-routing">4.2 Routing</h4>
<p>Selecting the right model, tool, or agent for a given request.</p>
<ul>
<li>Heuristic routing rules</li>
<li>LLM-based router prompts</li>
<li>Routing by complexity, sensitivity or domain</li>
<li>Combining cost and quality constraints</li>
</ul>
<h4 id="43-parallelisation">4.3 Parallelisation</h4>
<p>Running independent tasks concurrently to improve throughput.</p>
<ul>
<li>Fan-out calls to tools or models</li>
<li>Aggregating and merging results</li>
<li>Handling partial failures</li>
<li>Timeouts and cancellation strategies</li>
</ul>
<h4 id="44-planning--goal-management">4.4 Planning &amp; goal management</h4>
<p>Creating and adjusting plans to meet explicit goals.</p>
<ul>
<li>Turning user goals into sub-tasks</li>
<li>Ordered and dependency-aware task lists</li>
<li>Replanning when state changes</li>
<li>Tracking progress against a goal</li>
</ul>
<h4 id="45-goal-setting--monitoring">4.5 Goal setting &amp; monitoring</h4>
<p>Defining success criteria and checking whether they are met.</p>
<ul>
<li>Clear definitions of ‚Äúdone‚Äù</li>
<li>Agent-visible metrics or checkpoints</li>
<li>Self-assessment cycles (‚Äúdid I achieve the goal?‚Äù)</li>
<li>Triggering escalation if goals cannot be met</li>
</ul>
<h4 id="46-advanced-reasoning-techniques">4.6 Advanced reasoning techniques</h4>
<p>Using structured reasoning styles to improve accuracy.</p>
<ul>
<li>Chain-of-Thought (step-by-step reasoning)</li>
<li>Tree-of-Thought and exploring multiple paths</li>
<li><a href="https://arxiv.org/abs/2210.03629">ReAct</a> (reasoning plus acting with tools)</li>
<li>Self-correction and iterative refinement</li>
</ul>
<p>‚∏ª</p>
<h3 id="5-tools-skills--external-systems">5. Tools, Skills &amp; External Systems</h3>
<p>Connecting agents to external capabilities and designing those capabilities well.</p>
<h4 id="51-tool-and-function-calling">5.1 Tool and function calling</h4>
<p>Letting the model invoke deterministic operations.</p>
<ul>
<li>Tool interface design and arguments</li>
<li>Idempotent and side-effecting tools</li>
<li>Handling tool failures and retries</li>
<li>Limiting what tools are available when</li>
</ul>
<h4 id="52-tool-ecosystems-and-mcp">5.2 Tool ecosystems and MCP</h4>
<p>Organising tools into discoverable, reusable ecosystems.</p>
<ul>
<li><a href="https://modelcontextprotocol.io/">Model Context Protocol (MCP)</a> servers and tool definitions</li>
<li>Describing resources and prompts</li>
<li>Versioning and compatibility</li>
<li>Discoverability and documentation</li>
</ul>
<h4 id="53-enterprise-and-saas-integration">5.3 Enterprise and SaaS integration</h4>
<p>Connecting agents to real systems to actually do work.</p>
<ul>
<li>REST and GraphQL APIs</li>
<li>Databases and data warehouses</li>
<li>Enterprise services (CRM, ticketing, HR, core systems, etc.)</li>
<li>Handling authentication, rate limits and quotas</li>
</ul>
<p>‚∏ª</p>
<h3 id="6-multi-agent-systems--inter-agent-communication">6. Multi-Agent Systems &amp; Inter-Agent Communication</h3>
<p>Using multiple specialised agents that collaborate over well-defined protocols.</p>
<h4 id="61-role-based-multi-agent-design">6.1 Role-based multi-agent design</h4>
<p>Assigning clear responsibilities to different agents.</p>
<ul>
<li>Specialist vs generalist agents</li>
<li>Manager‚Äìworker patterns</li>
<li>Critic/reviewer agents</li>
<li>Domain vs workflow roles</li>
</ul>
<h4 id="62-collaboration-patterns">6.2 Collaboration patterns</h4>
<p>Structuring how multiple agents work together.</p>
<ul>
<li>Sequential hand-off</li>
<li>Parallel teams aggregating results</li>
<li>Debate or &ldquo;argue then agree&rdquo; patterns</li>
<li>Escalation to higher-authority agents</li>
</ul>
<h4 id="63-inter-agent-communication-standards">6.3 Inter-agent communication standards</h4>
<p>Using standard protocols so agents from different frameworks can talk.</p>
<ul>
<li>Agent cards describing capabilities</li>
<li>Task and message formats</li>
<li>Artifacts and streaming results</li>
<li>HTTP / JSON-RPC based interaction</li>
</ul>
<h4 id="64-a2a-style-discovery--interaction">6.4 A2A-style discovery &amp; interaction</h4>
<p>Finding and calling remote agents reliably.</p>
<ul>
<li>Well-known URIs and registries</li>
<li>Context identifiers for long-running tasks</li>
<li>Polling vs streaming updates</li>
<li>Security boundaries between agents</li>
</ul>
<p>‚∏ª</p>
<h3 id="7-memory--learning">7. Memory &amp; Learning</h3>
<p>Giving agents continuity over time and allowing them to improve.</p>
<h4 id="71-short-term-memory">7.1 Short-term memory</h4>
<p>Tracking state within a session or workflow.</p>
<ul>
<li>Conversation buffers</li>
<li>Current plan and sub-task state</li>
<li>Local scratchpads for reasoning</li>
<li>Limits and reset strategies</li>
</ul>
<h4 id="72-long-term-memory">7.2 Long-term memory</h4>
<p>Persisting information across sessions and tasks.</p>
<ul>
<li>User preferences and profiles</li>
<li>Project or case histories</li>
<li>Vector memories and knowledge bases</li>
<li>Expiry, pruning and privacy controls</li>
</ul>
<h4 id="73-learning-and-adaptation">7.3 Learning and adaptation</h4>
<p>Letting systems improve from feedback and data.</p>
<ul>
<li>Reinforcement learning and preference learning</li>
<li>Updating retrieval corpora and memories</li>
<li>Policy updates from evaluation results</li>
<li>Guarded finetuning where appropriate</li>
</ul>
<p>‚∏ª</p>
<h3 id="8-safety-robustness--human-partnership">8. Safety, Robustness &amp; Human Partnership</h3>
<p>Keeping systems safe, resilient and aligned with people.</p>
<h4 id="81-guardrails-and-content-safety">8.1 Guardrails and content safety</h4>
<p>Preventing harmful, non-compliant or out-of-scope behaviour.</p>
<ul>
<li>Input validation and sanitisation</li>
<li>Output filtering and safety checks</li>
<li>Behavioural constraints in prompts</li>
<li>Dedicated safety models or agents</li>
</ul>
<h4 id="82-exception-handling--recovery">8.2 Exception handling &amp; recovery</h4>
<p>Dealing gracefully with errors and degraded conditions.</p>
<ul>
<li>Error detection and logging</li>
<li>Retries and fallbacks</li>
<li>Graceful degradation of features</li>
<li>State rollback and escalation</li>
</ul>
<h4 id="83-human-in-the-loop-collaboration">8.3 Human-in-the-loop collaboration</h4>
<p>Designing for human oversight and joint work.</p>
<ul>
<li>Human review for sensitive actions</li>
<li>Escalation policies and thresholds</li>
<li>Feedback loops to improve agents</li>
<li>Interfaces for humans to correct or override</li>
</ul>
<h4 id="84-security--access-control">8.4 Security &amp; access control</h4>
<p>Keeping data and capabilities properly protected.</p>
<ul>
<li>Authentication and authorisation</li>
<li>Least-privilege tool and data access</li>
<li>Secrets management</li>
<li>Network and tenant isolation</li>
</ul>
<p>‚∏ª</p>
<h3 id="9-resource--priority-management">9. Resource &amp; Priority Management</h3>
<p>Using time, money and compute wisely while choosing what to do first.</p>
<h4 id="91-resource-aware-optimisation">9.1 Resource-aware optimisation</h4>
<p>Balancing quality against time and cost.</p>
<ul>
<li>Choosing between cheap vs expensive models</li>
<li>Latency-sensitive vs offline workflows</li>
<li>Bandwidth and storage-aware strategies</li>
<li>Fallback models and graceful degradation</li>
</ul>
<h4 id="92-task-and-goal-prioritisation">9.2 Task and goal prioritisation</h4>
<p>Deciding which task or goal the agent should work on next.</p>
<ul>
<li>Scoring by urgency, impact and dependencies</li>
<li>Scheduling and queues</li>
<li>Dynamic reprioritisation as conditions change</li>
<li>Aligning agent priorities with business objectives</li>
</ul>
<p>‚∏ª</p>
<h3 id="10-evaluation-monitoring--operations">10. Evaluation, Monitoring &amp; Operations</h3>
<p>Making sure systems work, stay healthy and improve over time.</p>
<h4 id="101-evaluation-and-metrics">10.1 Evaluation and metrics</h4>
<p>Measuring whether the system is actually good.</p>
<ul>
<li>Accuracy, relevance and helpfulness metrics</li>
<li>RAG-specific metrics (faithfulness, grounding)</li>
<li>Human rating workflows</li>
<li>Benchmark and regression suites</li>
</ul>
<h4 id="102-monitoring--observability">10.2 Monitoring &amp; observability</h4>
<p>Watching live systems and catching problems early.</p>
<ul>
<li>Latency and error tracking</li>
<li>Token and cost usage monitoring</li>
<li>Concept drift and behaviour drift detection</li>
<li>Logs and traces for auditability</li>
</ul>
<h4 id="103-llmops--agentops">10.3 LLMOps / AgentOps</h4>
<p>Running AI systems as first-class production services.</p>
<ul>
<li>CI/CD pipelines for prompts, tools and configs</li>
<li>Versioning of prompts, models and policies</li>
<li>Canary and shadow deployments</li>
<li>Rollbacks and kill switches</li>
</ul>
<p>‚∏ª</p>
<h3 id="11-frameworks-platforms--tooling">11. Frameworks, Platforms &amp; Tooling</h3>
<p>Using the ecosystems that make all of the above practical.</p>
<h4 id="111-orchestration-and-agent-frameworks">11.1 Orchestration and agent frameworks</h4>
<p>Building complex workflows without reinventing the wheel.</p>
<ul>
<li><a href="https://www.langchain.com/">LangChain</a>, <a href="https://www.llamaindex.ai/">LlamaIndex</a>, <a href="https://learn.microsoft.com/semantic-kernel/">Semantic Kernel</a></li>
<li><a href="https://www.crewai.com/">CrewAI</a>, <a href="https://microsoft.github.io/autogen/">AutoGen</a>, Swarm-style frameworks</li>
<li><a href="https://google.github.io/adk-docs/">Google ADK</a> and similar agent toolkits</li>
<li><a href="https://huggingface.co/">Hugging Face</a> ecosystems (model hub, Inference, Spaces)</li>
<li>Local model tooling and runtimes (for example <a href="https://lmstudio.ai/">LM Studio</a>)</li>
<li>Workflow engines and state machines</li>
</ul>
<h4 id="112-cloud-ai-platforms">11.2 Cloud AI platforms</h4>
<p>Using managed services for models and agents.</p>
<ul>
<li><a href="https://ai.azure.com/">Azure AI Foundry</a></li>
<li><a href="https://www.microsoft.com/en-us/microsoft-copilot/microsoft-copilot-studio">Copilot Studio</a></li>
<li><a href="https://aws.amazon.com/bedrock/">AWS Bedrock</a></li>
<li><a href="https://cloud.google.com/vertex-ai">Vertex AI</a> and similar</li>
</ul>
<h4 id="113-evaluation--monitoring-tools">11.3 Evaluation &amp; monitoring tools</h4>
<p>Leveraging specialised tools for analysing behaviour.</p>
<ul>
<li><a href="https://langfuse.com/">LangFuse</a></li>
<li><a href="https://www.helicone.ai/">Helicone</a></li>
<li><a href="https://wandb.ai/">Weights &amp; Biases</a></li>
<li>General observability stacks (<a href="https://prometheus.io/">Prometheus</a>, <a href="https://grafana.com/">Grafana</a>, <a href="https://www.datadoghq.com/">Datadog</a>, <a href="https://www.honeycomb.io/">Honeycomb</a>, etc.)</li>
</ul>
<h4 id="114-document-and-data-tooling">11.4 Document and data tooling</h4>
<p>Supporting ingestion and preprocessing at scale.</p>
<ul>
<li><a href="https://unstructured.io/">Unstructured.io</a> and PDF parsers</li>
<li>ETL and data pipelines</li>
<li>Storage backends for datasets and document collections</li>
<li>Connectors into enterprise systems</li>
</ul>
<h2 id="where-this-leaves-us">Where this leaves us</h2>
<p>This list is intentionally dense and a little overwhelming, because the space itself is. You don&rsquo;t need to become an expert in every item in this list; getting comfortable with even a handful of them will open up new kinds of systems to design and new questions to wrestle with, in a space where many of the patterns and &ldquo;best practices&rdquo; are still being written. In a world where more and more of our stacks include components that are, by design, non-deterministic, we have a rare opportunity: to get curious early, experiment while things are still fluid, and help redefine what good engineering looks like - especially around inference, orchestration and agents - bringing the discipline, judgement and curiosity that make these systems something people can trust.</p>
]]><![CDATA[<hr><p>Thanks for reading this post via RSS! üëã</p>]]><![CDATA[<a href="mailto:annie.luxton@gmail.com?subject=A Whole New World">Reply to this post by email</a>]]></description>
    </item>
    <item>
      <title>The Extra Load We Carry</title>
      <link>http://annievella.com/posts/the-extra-load-we-carry/</link>
      <pubDate>Tue, 12 Aug 2025 00:00:00 +1300</pubDate><author>annie.luxton@gmail.com (Annie Vella)</author>
      <guid>http://annievella.com/posts/the-extra-load-we-carry/</guid>
      <description>
      
      
      <![CDATA[<p>When I came across a recent Harvard Business Review <a href="https://hbr.org/2025/08/research-the-hidden-penalty-of-using-ai-at-work">article</a> on the hidden penalty of using AI at work, it wasn&rsquo;t the AI part that stood out to me, even though I&rsquo;m studying this very topic as part of my Master&rsquo;s of Engineering. Yes, the AI findings were interesting, but what stopped me in my tracks was something else: the &ldquo;competence penalty&rdquo; women pay.</p>
<p>The research put numbers to it:</p>
<blockquote class="large-quote" style="font-size: 1.5em; margin: 30px 40px 30px 40px">The competence penalty was more than twice as severe for female engineers, who faced a 13% reduction compared to 6% for male engineers.</blockquote>
<p>The experiment was simple: engineers reviewed the exact same piece of Python code, with the only difference being whether they were told it had been written with the assistance of AI. Turns out women are essentially carrying a heavier burden of doubt for the same contributions.</p>
<p>Even worse, the harshest critics were men who didn&rsquo;t use AI themselves - they judged women <em>26% more severely than men</em> for <em>identical AI-assisted work</em>.</p>
<p>Let that sink in for a moment.</p>
<p>It&rsquo;s worth noting that all the engineers in the study were from the same company, so the results may say as much about that company&rsquo;s culture as the industry at large.</p>
<p>But unfortunately they line up all too well with the lived experiences of many women in tech. Reading those numbers brought that familiar sting of recognition - here was research finally putting concrete data to something that&rsquo;s hard to put your finger on, but quietly feeds imposter syndrome throughout our careers.</p>
<p>For some of us, it starts even earlier than the first critical code review. Like when I told my computer studies teacher I wanted to learn how to code and they said I&rsquo;d have to transfer to the local boys&rsquo; school. Or at my high school graduation, after being awarded Dux of my college, the school&rsquo;s computer teacher asked what I was planning next. I told her I was off to study computer science at university. Her response? <em>&ldquo;Worst decision you&rsquo;ll ever make. The boys will run circles around you, and you&rsquo;ll be the worst in the class.&rdquo;</em></p>
<p>She didn&rsquo;t believe I could. She didn&rsquo;t believe I should even <em>try</em>.</p>
<p>Thankfully, years of navigating new countries and school systems mid-year (my father was a diplomat) had helped me build a fair amount of resilience, so I didn&rsquo;t let that sway me. But it did stick with me. I still marvel at how someone could so flippantly squash someone else&rsquo;s dreams like that. A child&rsquo;s dreams, none the less.</p>
<p>I&rsquo;ve always said, and still believe, there&rsquo;s nothing else I could imagine doing. This was my passion, and no one was going to talk me out of pursuing it. Her doubt became my fuel.</p>
<p>That resilience has been tested several times throughout my career. Like that time I asked for access to logs to debug a memory leak and was brushed off for weeks, until my husband, <a href="https://jasonvella.com">Jason Vella</a>, (who&rsquo;s also a software engineer and worked at the same company) asked for the same logs and got them immediately. He passed them onto me, and I used them to teach myself WinDbg, found the leak, and fixed it. One of my proudest moments, actually, but also one I&rsquo;d annoyingly had to fight for.</p>
<p>Over the years, I&rsquo;ve worked in four countries and nearly a dozen companies, and the pattern is remarkably consistent. I&rsquo;ve often had to prove myself just a little more, and for a little longer, than it seems to take for my male colleagues.</p>
<p>However, for all those subtle extra challenges, I&rsquo;ve also had enormous support from many - mostly men, in fact - who have taught me, challenged me, and pushed me to be and do my best every single day. Their encouragement has been just as real as the obstacles, and I&rsquo;m deeply grateful for it.</p>
<p>This mix of obstacles and support has taught me something important: the difference often comes down to who believes in you from the start. For all the talk about getting more women into tech, here&rsquo;s a thought: maybe stop discouraging them in the first place? Support them early. <em>Show</em> them what&rsquo;s possible - because too often, the gap exists only because they&rsquo;ve been told it&rsquo;s there.</p>
<p>That&rsquo;s why programmes like <a href="https://shadowtech.nz">ShadowTech</a> matter so much. This year, ShadowTech25 is giving more than 1,200 girls from 80+ schools across New Zealand the chance to spend a real day in tech - meeting mentors, touring workplaces, and seeing firsthand just how diverse and exciting a career in technology can be. Contributing to their panel discussions at <a href="https://westpac.co.nz">Westpac</a> over the past few years has been a chance for me to reflect on my own pathway, and to turn my obstacles into stepping stones for the next generation.</p>
<p>Exposure leads to possibility, and possibility changes everything.</p>
<p>But there&rsquo;s another side to this work. Just as we need to give girls opportunities to play with computers and learn to code early, we also need to teach boys that women can, and do, excel in these roles. Avoid baking in bias from the start. And when we get to the workplace, leadership needs to set the tone. Leaders cast a long shadow, and when they lead by example - offering fair opportunities, recognising contributions evenly, and calling out unfair behaviour - it sends a signal that bias isn&rsquo;t tolerated here. Culture is contagious, and every time someone, regardless of gender or background, challenges an unfair assumption, it chips away at the barrier for the next person.</p>
<p>Maybe then, just maybe, we&rsquo;ll get a little closer to letting everyone play on a level field, where identical work gets identical judgment, regardless of <em>who</em> wrote it. Where the next generation can start their journey without the weight of someone else&rsquo;s low expectations on their back.</p>
<p>I should add that despite all this - the extra proving, the subtle barriers, the competence penalties that research now validates - I have absolutely <em>loved</em> this career. The joy of solving complex problems, creating systems that matter, and working alongside brilliant minds has definitely outweighed every obstacle. The quiet satisfaction of knowing I could do it all along adds a certain sweetness to the journey.</p>
<p>Would I choose this path again, knowing what I know now about the extra load we carry?</p>
<p>Without hesitation. Because someone has to prove that teacher wrong.</p>
]]><![CDATA[<hr><p>Thanks for reading this post via RSS! üëã</p>]]><![CDATA[<a href="mailto:annie.luxton@gmail.com?subject=The Extra Load We Carry">Reply to this post by email</a>]]></description>
    </item>
    <item>
      <title>The Heart of Software Engineering Still Beats</title>
      <link>http://annievella.com/posts/the-heart-of-software-engineering-still-beats/</link>
      <pubDate>Fri, 27 Jun 2025 00:00:00 +1300</pubDate><author>annie.luxton@gmail.com (Annie Vella)</author>
      <guid>http://annievella.com/posts/the-heart-of-software-engineering-still-beats/</guid>
      <description>
      
      
      <![CDATA[<p>A few weeks ago, I had a conversation that&rsquo;s stayed with me. A colleague from another department said: <em>&ldquo;I&rsquo;ve always been able to read and understand code, even debug it, but I could never write it.&rdquo;</em></p>
<p>Something about this revelation stayed with me. Most people I&rsquo;ve met outside the software engineering world tend to describe code as unintelligible - like hieroglyphics. I guess that&rsquo;s why I&rsquo;ve always assumed: if someone couldn&rsquo;t write code, they probably couldn&rsquo;t read it either.</p>
<p>But this person isn&rsquo;t a software engineer. They don&rsquo;t work in a role where coding is expected. And yet, they can read it. Follow its logic. Understand enough to debug it.</p>
<p>That was new to me. I&rsquo;ve worked with plenty of people who can&rsquo;t code - that&rsquo;s normal. But someone who can read code fluently, yet feels unable to write it, struck me as an unusual inversion of what I&rsquo;d always assumed.</p>
<h2 id="modelling-not-just-typing">Modelling, Not Just Typing</h2>
<p>Writing code isn&rsquo;t just knowing syntax. It&rsquo;s not just about conditionals or classes or regexes. At its heart, writing code is modelling - the ability to form a structured mental model of a process, a system, or an idea, and then encode it in a way that a machine can understand.</p>
<p>What you&rsquo;re creating is a <em>representation</em>: a digital reflection of something real, or imagined. Sometimes that model lives in your head. Sometimes it spills out across a whiteboard or a sheet of paper. But it&rsquo;s always there - an abstraction you&rsquo;re building, refining, naming. You&rsquo;re spotting patterns, finding generalisations, shaping structure from chaos. And then translating all of it into syntactically correct code.</p>
<p>This is what&rsquo;s always drawn me to programming. The act of shaping a mental image, refining it through thought, and watching it come to life. Even today, after decades in this industry, there&rsquo;s still something magical about it.</p>
<p>As <a href="https://en.wikipedia.org/wiki/Fred_Brooks">Fred Brooks</a>, author of the very famous book <a href="https://en.wikipedia.org/wiki/The_Mythical_Man-Month">The Mythical Man-Month</a>, put it:</p>
<blockquote class="large-quote" style="font-size: 1.5em; margin: 30px 40px 0 40px">The programmer, like the poet, works only slightly removed from pure thought‚Äëstuff. He builds his castles in the air, from air, creating by exertion of the imagination...</blockquote>
<p style="margin: 10px 40px 30px 40px; font-size: 0.8em;"><em>‚Äî Frederick P. Brooks, The Mythical Man-Month, Chapter 1, Addison-Wesley, 1975</em></p>
<p>That image - that castle in the air - is what draws many of us to code. It&rsquo;s abstract, fragile, and yet, when the build succeeds, it becomes something real. A living, running representation of our ideas.</p>
<p>And we don&rsquo;t get there by accident. The transition from mental model to working system happens through <strong>design</strong> - a process of making trade-offs, choosing abstractions, and shaping the code in a way that reflects not just what works, but what makes sense.</p>
<h2 id="design-isnt-a-phase">Design Isn&rsquo;t a Phase</h2>
<p>In some organisations, design is treated as a one-off activity. It happens at the beginning of a project, often in a different room, done by someone else with a different title. Sometimes it&rsquo;s even handed down like a blueprint to be implemented.</p>
<p>But anyone who&rsquo;s spent time building software knows: design is <em>everywhere</em>. It&rsquo;s in how you break down a problem. In the abstractions you choose. In the edge cases you decide to handle - or not. Design happens during implementation, during testing, during bug fixing, and even while reading logs to understand why something failed in production.</p>
<p><a href="https://en.wikipedia.org/wiki/John_Ousterhout">John Ousterhout</a> said it plainly in his <a href="https://www.youtube.com/watch?v=lz451zUlF-k">recent interview</a> with <a href="https://www.linkedin.com/in/gergelyorosz/">Gergely Orosz</a>:</p>
<blockquote class="large-quote" style="font-size: 1.5em; margin: 30px 40px 0 40px">My personal belief is that design permeates the entire development process. You do it upfront, you do it while you're coding, you do it while you're testing, you do it while you're fixing bugs; you should constantly be thinking about design.</blockquote>
<p style="margin: 10px 40px 30px 40px; font-size: 0.8em;"><em>‚Äî John Ousterhout, interview with Gergely Orosz</em></p>
<p>Design isn&rsquo;t a step we move past - it&rsquo;s how we evolve our representations. It&rsquo;s how we learn what we missed, or overcomplicated, or misunderstood. And it&rsquo;s deeply satisfying. There&rsquo;s a quiet joy in realising you&rsquo;ve found a better way to shape something. That your system is more robust, more elegant, more humane because of it. Sometimes that shift is architectural. Sometimes it&rsquo;s a single line. The devil might be in the details - but so is the beauty. And that&rsquo;s where the craft lives too.</p>
<h2 id="a-memory-that-still-moves-me">A Memory That Still Moves Me</h2>
<p>I still remember the first time I saw an idea come to life on screen. I was six years old, sitting at my Commodore 64, carefully typing out lines from a manual I barely understood.</p>
<p>There were no variables to name. No functions to design. I was just copying commands - faithfully, line by line. I didn&rsquo;t know what a loop was, or what DATA meant. But I typed RUN, pressed RETURN, and something happened.</p>
<p>A face appeared.</p>
<figure class="center"><img src="http://annievella.com/images/commodore-64-sprite.jpeg"
    alt="Commdore 64 Sprite"><figcaption>
      <p>My first creation in BASIC, from the Commodore 64 manual</p>
    </figcaption>
</figure>

<p>Not a great one. Just a blocky pixel sprite. But it <em>moved</em>. It smiled at me from the screen, and I smiled back - stunned that text I&rsquo;d typed had become something visual that moved.</p>
<p>I wasn&rsquo;t designing anything of my own. I wasn&rsquo;t solving a problem or building a system from scratch. But at six years old, that didn&rsquo;t matter. Seeing those symbols turn into something alive on screen was enough to hook me for life.</p>
<p>Looking back now, I realise what captivated me wasn&rsquo;t the syntax. It was the revelation of possibility - that words could become images. That logic could shape behaviour. That you could <em>model something invisible, nothing more than pure thought</em>, and then <em>run it</em>.</p>
<p>Even now, decades later, that moment still moves me.</p>
<h2 id="what-we-learned-to-see">What We Learned to See</h2>
<p>Over time, the magic becomes more than just the image on the screen. You start to notice what&rsquo;s behind it.</p>
<p>The way the code is structured. Where it flows, and where it fights itself. You begin to <em>feel</em> when a function is doing too much. When an abstraction leaks. When a variable name is quietly misleading.</p>
<p>You might hear about these principles in lectures or read them in books, but theory alone doesn&rsquo;t stick. It&rsquo;s when you inherit a codebase that fights you at every turn that you truly understand why these things matter. When you spend hours untangling what should have been simple. When you feel the cost of all those shortcuts taken over the years.</p>
<p>That&rsquo;s when you develop an intuition - an internal radar for what&rsquo;s brittle, what&rsquo;s elegant, what&rsquo;s deceptively complex.</p>
<p>Code starts to feel less like a puzzle to solve and more like a conversation to understand. You begin to recognise fingerprints. This bit was clearly rushed. That bit was lovingly crafted. This change came from someone who knew the system inside out. That one&hellip; maybe not.</p>
<p>In this evolution, the magic deepens. What started as wonder at seeing code come to life on screen becomes appreciation for how we organise thought itself. Writing code isn&rsquo;t just how we instruct a machine - it&rsquo;s how we give shape to our own understanding. A way to turn thought into structure. Intent into form.</p>
<h2 id="the-test-we-all-had-to-pass">The Test We All Had to Pass</h2>
<p>For many of us, reading and writing code wasn&rsquo;t just a skill, it was a test. Quite literally.</p>
<p>Coding interviews. Live whiteboarding. We were asked to write functions from scratch, under pressure, with someone watching. We weren&rsquo;t just trying to solve problems - we were trying to <em>show our thinking</em>.</p>
<p>We prepared diligently. Memorised sorting algorithms. Practised recursion and dynamic programming. Optimised for time and space complexity. And for all their flaws, these interviews taught us something. They taught us how to trace logic out loud. How to structure an approach. How to fail gracefully, and recover.</p>
<p>For some, platforms like <a href="https://leetcode.com/">LeetCode</a> and <a href="https://www.hackerrank.com">HackerRank</a> evolved beyond mere preparation. They became a kind of personal challenge. A way to stay sharp. To prove to yourself that you still could. Leaderboards and contests sprang up, and with them, a sense of competition. Bragging rights. Mastery, on display.</p>
<p>We wore those battle scars with pride. Not because the process was fair, but because it was hard. Because it demanded something real from us: our ability to model, abstract, and express ideas clearly, under pressure.</p>
<p>It was stressful, yes. Sometimes unfair. But it reinforced that writing code was a kind of thinking - a visible trace of our structured understanding. And being good at it meant being able to shape those models quickly and clearly.</p>
<p>And now?</p>
<p>Well, it&rsquo;s complicated. AI coding assistants can pass these tests too. They can write elegant solutions. Sometimes better than we can. They don&rsquo;t get nervous. They don&rsquo;t forget to handle an edge case. They just&hellip; output.</p>
<p>Which makes you wonder: if the thing that defined at least part of our entry into this field can now be automated, what does that mean for what comes next?</p>
<h2 id="a-shift-that-feels-personal">A Shift That Feels Personal</h2>
<p>Maybe that&rsquo;s why the rise of generative AI is hitting us in a different way. It&rsquo;s not just about productivity gains. It&rsquo;s about what&rsquo;s being displaced.</p>
<p>A few months ago, I wrote a post called <a href="https://annievella.com/posts/the-software-engineering-identity-crisis/">The Software Engineering Identity Crisis</a>. It clearly struck a nerve - almost 60,000 views in just a few weeks. Dozens of engineers reached out personally to share their experiences. The message was consistent: <em>&ldquo;Yes. This is exactly what I&rsquo;ve been feeling, but hadn&rsquo;t put into words.&rdquo;</em></p>
<p>There&rsquo;s a quiet discomfort rippling through our industry. And I think this is part of it.</p>
<p>We&rsquo;ve spent years honing a craft that&rsquo;s part logic, part intuition, part art. And now we&rsquo;re watching tools - not just assist us, but perform the very thing many of us took deep pride in: that mental modeling, that translation of abstract thought into executable form.</p>
<p>A recent <em>New York Times</em> article captured this tension. Titled <a href="https://www.nytimes.com/2025/05/25/business/amazon-ai-coders.html">At Amazon, Some Coders Say Their Jobs Have Begun to Resemble Warehouse Work</a>, it describes how some engineers feel monitored, controlled, and pushed to deliver at unrelenting speed, echoing the dynamics of factory labour. The piece suggests a subtle but profound shift in the nature of engineering work: from craft to throughput. From autonomy to optimisation.</p>
<p>And one line hit particularly hard:</p>
<blockquote class="large-quote" style="font-size: 1.5em; margin: 30px 40px 0 40px">This shift from writing to reading code can make engineers feel as if they are bystanders in their own jobs.</blockquote>
<p style="margin: 10px 40px 30px 40px; font-size: 0.8em;"><em>‚Äî The New York Times, May 2025</em></p>
<p>This is what devaluation can look like. Not being replaced, but being sidelined. The moments we used to savour - the ones that brought flow, and joy, and pride - are becoming rarer. Shorter. Edged out by something faster, more efficient, and strangely hollow.</p>
<p>We&rsquo;re adapting, yes. But part of us is grieving too.</p>
<h2 id="finding-our-place">Finding Our Place</h2>
<p>There&rsquo;s no denying it - this technology is absolutely incredible. It can write code that many people feel they never could. But along with that comes a sense that something uniquely human is being devalued - that creative spark that transforms abstract thought into working systems.</p>
<p>In the art community, a similar conversation is happening. Artists have started using &ldquo;<a href="https://www.forbes.com/sites/lesliekatz/2024/07/17/human-intelligence-art-movement-takes-defiant-stand-against-ai/">Created with Human Intelligence</a>&rdquo; badges on their work.</p>
<figure class="center"><img src="http://annievella.com/images/created-with-human-intelligence.png"
    alt="Created with Human Intelligence"><figcaption>
      <p>Beth Spencer - Created with Human Intelligence</p>
    </figcaption>
</figure>

<p>Kick-started by <a href="https://bethspencerillustration.com">Beth Spencer</a>, this is a quiet rebellion against the tide of AI-generated content. Not because AI art isn&rsquo;t impressive, but because there&rsquo;s something worth preserving in the human creative process itself.</p>
<p>Don&rsquo;t get me wrong - I&rsquo;m not suggesting we resist progress. The world is changing, and we <em>need to change with it</em>. This shift is opening up new possibilities we‚Äôre only just beginning to explore. But I still carry a deep appreciation for the moments when code felt like pure magic - when shaping an idea into something runnable brought clarity, joy, and a sense of creation that was entirely our own.</p>
<p>The future of software engineering is being redefined before our eyes. If you, like me, have taken pleasure in the creation of code, we need to find new ways to experience that same satisfaction. These tools are improving rapidly, and businesses are eager to leverage them to their full potential.</p>
<p>For now, we still need to guide these assistants carefully. But that will change over time. The question becomes: how do we preserve what matters most about our craft while embracing what comes next?</p>
<h2 id="from-prompts-to-context">From Prompts to Context</h2>
<p>At its core, programming has always been about modelling - taking something abstract and giving it a structure that can run. Sometimes we do that by writing code. But more and more, we&rsquo;re doing it by shaping the context around a tool that writes the code for us.</p>
<p>Prompt engineering felt like the next abstraction layer. A clever way to influence the output. And for a while, it was.</p>
<p>But as these tools evolve, we&rsquo;re learning that the real power isn&rsquo;t in the prompt. It&rsquo;s in the <strong>context</strong>. The true challenge lies in encoding the messy real world into something a machine can work with - that&rsquo;s far harder than simply generating code.</p>
<figure class="center"><img src="http://annievella.com/images/tweet-context-engineering.png"
    alt="Is context engineering the new prompt engineering?"><figcaption>
      <p>Is context engineering the new prompt engineering?</p>
    </figcaption>
</figure>

<p>The systems that perform best aren&rsquo;t those with the cleverest prompts - they&rsquo;re the ones with the clearest scaffolding. Good documentation. Consistent naming. Representative examples. The kind of subtle cues that help an AI understand what <em>good</em> looks like in <em>your specific context</em>.</p>
<p>As Ibrahem Amer explains in his article on <a href="https://www.linkedin.com/pulse/prompt-engineering-vs-context-ibrahem-amer-inzdf/">prompt engineering versus context engineering</a>, this approach involves multiple layers: from foundational knowledge structures to data integration systems to the moment-by-moment context delivery. It&rsquo;s not just about crafting clever instructions - it&rsquo;s about building an entire environment in which the AI can operate effectively.</p>
<p>And this changes how we show our skill.</p>
<p>It&rsquo;s not about being a prompt whisperer. It&rsquo;s about structuring what the tool sees. Giving it the right framing. Guiding its attention. Helping it learn from the materials we&rsquo;ve already shaped.</p>
<p>In other words, we&rsquo;re still designing systems. Still modelling complexity. Still shaping abstractions.</p>
<p>The shape of our work may be changing. But the underlying skill - the ability to see clearly, structure thoughtfully, and model well - remains at the heart of it all.</p>
<h2 id="the-convergence-of-tool-and-component">The Convergence of Tool and Component</h2>
<p>This shift in skill - from crafting code to crafting prompts, and now, to crafting context - becomes even more important when we realise that AI isn&rsquo;t just helping us build software; it&rsquo;s becoming part of the software itself.</p>
<p>AI is no longer just a tool we use to build software. It&rsquo;s becoming a component inside the systems we build. But when we use AI to help us build software that contains AI&hellip; where does the boundary lie?</p>
<p>The distinction starts to blur. The AI becomes both the engine and the product - at least, that&rsquo;s how it can feel. And while the boundary is blurry in practice, thinking of them separately can still be a helpful distinction, especially when things start to feel fluid.</p>
<p>This idea resonated strongly with me during <a href="https://www.linkedin.com/in/simonwardan/">Simon Warden</a>&rsquo;s talk, <a href="https://australian.software/YOW2025/">AI as the Engine, Not the Product</a>, at the <a href="https://yowcon.com/tech-leaders-brisbane-2025">YOW! Tech Leaders Summit</a>. He articulated how the most successful AI implementations aren&rsquo;t those that just expose capabilities, but those that orchestrate them thoughtfully within systems.</p>
<p>We&rsquo;re still engineers. But the materials have changed.</p>
<p>The skill isn&rsquo;t vanishing. It&rsquo;s resurfacing - at a different altitude.</p>
<h2 id="the-joy-reframed">The Joy, Reframed</h2>
<p>We still model things that don&rsquo;t exist yet. We still shape invisible systems out of thought and logic and names. We still give <em>form to ideas</em>.</p>
<p>That joy hasn&rsquo;t gone. But its expression is shifting.</p>
<p>Today, AI handles more of the syntax. More of the scaffolding. But the architecture - the imagination behind it - is still ours to hold. The abstractions we shape. The intent we encode. The representations we choose.</p>
<p>And maybe now, with these tools beside us, we can go further. Be bolder. Imagine more ambitious castles. Explore stranger terrain. Spend less time typing - and more time thinking. Designing. Modelling.</p>
<p>Because the real craft of software engineering was never about just writing code. It was always about what we were encoding - and why.</p>
<p>That hasn&rsquo;t changed.</p>
<p>So let&rsquo;s not forget the craft. Let&rsquo;s not leave it behind.</p>
<p>Let&rsquo;s carry it forward - clearer, faster, and maybe even more joyful than before.</p>
<p>We&rsquo;re not losing our craft. We&rsquo;re being asked to deepen it. And that&rsquo;s a challenge worth accepting.</p>
]]><![CDATA[<hr><p>Thanks for reading this post via RSS! üëã</p>]]><![CDATA[<a href="mailto:annie.luxton@gmail.com?subject=The Heart of Software Engineering Still Beats">Reply to this post by email</a>]]></description>
    </item>
    <item>
      <title>The Next Evolutionary Step</title>
      <link>http://annievella.com/posts/the-next-evolutionary-step/</link>
      <pubDate>Fri, 09 May 2025 00:00:00 +1200</pubDate><author>annie.luxton@gmail.com (Annie Vella)</author>
      <guid>http://annievella.com/posts/the-next-evolutionary-step/</guid>
      <description>
      
      
      <![CDATA[<p>The recent releases of Claude Code and OpenAI Codex caught my attention, but not for the reasons you might expect. I was puzzled by the enthusiasm they&rsquo;ve generated. These are, after all, terminal tools. In an era where graphical IDEs dominate, with tools like Cursor, Windsurf, and VSCode evolving toward ever-more seamless integrations, like &lsquo;<a href="https://www.linkedin.com/posts/tomkrcha_introducing-design-mode-for-cursor-activity-7325527044459524096-tqy7">Design Mode</a>&rsquo;, why are we getting excited about terminal-based AI coding tools that feel like a step backwards?</p>
<figure class="center"><img src="http://annievella.com/images/questprobe-featuring-spider-man.png"
    alt="Questprobe Featuring Spider-Man (1984)"><figcaption>
      <p><a href="https://youtu.be/bw6KY5XaF9M?si=Sbw74N5UA71Ad27K">Questprobe Featuring Spider-Man (1984)</a></p>
    </figcaption>
</figure>

<p>This is what comes to mind when I think of a natural-language-based CLI - an old Commodore 64 text adventure game that I used to play as a kid.</p>
<p>A move back to the basics seems odd but intriguing, so I decided to give them a try and see if I could figure out what all the fuss was about.</p>
<h2 id="claude-code">Claude Code</h2>
<p>Setting it up was a breeze. Just follow the instructions <a href="https://docs.anthropic.com/en/docs/claude-code/overview">here</a> and you&rsquo;ll be up and running in no time.</p>
<p>You&rsquo;ll need an Anthropic account because you need some money on your account before you can use Claude Code. I gave mine $5 USD and it was enough to build a couple of simple apps.</p>
<p>In a weird way, it feels like I&rsquo;m <em>playing</em> Questprobe Featuring Spider-Man but instead of asking it to go north, I&rsquo;m asking it to write me an app.</p>
<figure class="center"><img src="http://annievella.com/images/building-spider-man-2025.png"
    alt="Claude Code - Building Spider-Man"><figcaption>
      <p>Claude Code - Building Spider-Man</p>
    </figcaption>
</figure>

<p>From the simple prompt, <em>&ldquo;Can you create a web-based version of the text adventure game called Questprobe Featuring Spider-Man from 1984 - <a href="https://www.squakenet.com/game/questprobe-featuring-spider-man/">https://www.squakenet.com/game/questprobe-featuring-spider-man/</a> ?&rdquo;</em>, Claude Code generated a basic but functional web-based version of Questprobe Featuring Spider-Man in less than a minute.</p>
<figure class="center"><img src="http://annievella.com/images/spider-man-2025.png"
    alt="Claude Code Spider-Man"><figcaption>
      <p>Claude Code Spider-Man</p>
    </figcaption>
</figure>

<p>I really appreciated how it created a plan and then systematically ticked off each step, all from such a simple prompt. By default, it stops and asks you to confirm each significant step - but it also gives you the option to confirm and &ldquo;not ask again this session&rdquo;.</p>
<p>Well hello dear friend, <em>vigilance decrement</em>. I knew you&rsquo;d show up sooner or later.</p>
<p>It&rsquo;s far too enticing to select that option. After all, how much reviewing are you <em>really</em> doing in the terminal window? This reminds me of something I&rsquo;ve noticed about code reviews throughout my career - they&rsquo;re one of those activities that engineers know are valuable (especially for learning about the codebase and seeing how others solve problems), but rarely enjoy doing. In most teams, you&rsquo;ll find engineers having to repeatedly ask - sometimes even beg - their colleagues to review their code. It&rsquo;s not surprising really; we engineers love <em>creating</em> things, and reviewing someone else&rsquo;s code feels about as far from creation as writing tests does. Both are essential for quality, but they don&rsquo;t scratch that builder&rsquo;s itch.</p>
<h2 id="openai-codex">OpenAI Codex</h2>
<p>Setting it up is straightforward - just follow the instructions <a href="https://github.com/openai/codex">here</a>. As with Claude Code, you&rsquo;ll need an OpenAI account with some credit before you can use it.</p>
<p>I asked Codex to analyse a really old side project of mine - an iPad game called <em>Easter Egg Hunt</em> written in Objective-C back in 2013 or so. The prompt was simple: <em>&ldquo;Can you describe the purpose of the app?&rdquo;</em></p>
<figure class="center"><img src="http://annievella.com/images/openai-codex-easterhunt.png"
    alt="OpenAI Codex Easter Egg Hunt Description"><figcaption>
      <p>OpenAI Codex Easter Egg Hunt Description</p>
    </figcaption>
</figure>

<p>Within seconds, it produced a remarkably accurate description of the app - from the three themed environments (Garden, Beach, or Snow) to the core gameplay of eggs periodically &ldquo;popping&rdquo; up in random locations. It even caught implementation details like the particle effects and chimes every five eggs, the in-app purchase system for unlocking scenes, and the use of Localytics for analytics. All this without ever seeing the app running or having any screenshots - just pure code comprehension.</p>
<p>Encouraged, I pushed a little further. <em>&ldquo;Draw some high-value diagrams using Mermaid that would help a new engineer understand this codebase.&rdquo;</em></p>
<p>The results were genuinely impressive. Codex generated a series of clear, thoughtful visuals - from class relationship diagrams showing the core game structure to sequence diagrams illustrating the gameplay flow. These diagrams captured relationships that would take hours for a human to extract from unfamiliar code.</p>
<figure class="center"><img src="http://annievella.com/images/openai-codex-easterhunt-class-diagram.png"
    alt="OpenAI Codex Easter Egg Hunt Class Diagram"><figcaption>
      <p>OpenAI Codex Easter Egg Hunt Class Diagram</p>
    </figcaption>
</figure>

<figure class="center"><img src="http://annievella.com/images/openai-codex-easterhunt-sequence-diagram.png"
    alt="OpenAI Codex Easter Egg Hunt Sequence Diagram"><figcaption>
      <p>OpenAI Codex Easter Egg Hunt Sequence Diagram</p>
    </figcaption>
</figure>

<p>Think about onboarding - in minutes, a new engineer could understand a codebase that would normally take days to unravel.</p>
<p>While these CLI tools might seem like a step backward, I was starting to see glimpses of something more interesting emerging.</p>
<h2 id="beyond-the-terminal-interface">Beyond The Terminal Interface</h2>
<p>For developers used to modern IDEs, returning to the terminal might feel like a blast from the past. But focusing on the interface misses something crucial.</p>
<p>These tools aren&rsquo;t here to replace our IDEs - they represent the next natural evolutionary step in development. A step where AI intelligence can be embedded throughout our entire workflow.</p>
<p>Both OpenAI Codex and Claude Code can run in <em>headless mode</em>, allowing them to be integrated into pipelines, scheduled tasks, and automated testing suites. Claude Code offers a <a href="https://docs.anthropic.com/en/docs/claude-code/cli-usage#print-mode-details">non-interactive mode</a> designed for programmatic use. OpenAI Codex similarly supports a <a href="https://github.com/openai/codex#non-interactive--ci-mode">non-interactive / CI mode</a> for use in pipelines.</p>
<figure class="center"><img src="http://annievella.com/images/openai-codex-non-interactive-mode.png"
    alt="OpenAI Codex Non-Interactive Mode"><figcaption>
      <p>OpenAI Codex Non-Interactive Mode</p>
    </figcaption>
</figure>

<p>This capability transforms these AI assistants from mere copilots into programmable units of intelligence that can be woven seamlessly into our larger systems. The implications of this shift are significant.</p>
<p>Imagine this:</p>
<ul>
<li>After your build, test and deploy steps, get Claude Code to generate a series of diagrams for your codebase which it can then safely stash away in your documentation repository as a snapshot-in-time.</li>
<li>You know those pesky flaky tests that keep causing your pipeline to break but aren&rsquo;t always easy to fix (even if you did have time to look at them)? Why not get OpenAI Codex to help you fix them automatically?</li>
<li>It could perform a <em>pre-post-mortem</em> analysis - evaluating the combined impact of changes and assessing risks across all dimensions (operational incidents, security vulnerabilities, change reversibility) before they become real problems.</li>
</ul>
<p>What we&rsquo;re seeing is just the beginning. Think about all the repetitive, time-consuming steps in our development lifecycle - both inner loop activities like coding and outer loop activities like reviews and documentation. These tools are opening up possibilities to automate not just the coding itself, but also those friction-heavy outer loop activities that often slow us down. As <a href="https://abinoda.com">Adi Noda</a>, CEO and cofounder of DX, recently said in a Gartner Podcast that was asking the question <em><a href="https://open.spotify.com/episode/3W2VCLGTI31is9AFbgDhGr?si=eaca8a061feb4e24">Does Developer Experience Really Matter?</a></em>:</p>
<blockquote>
<p>We tend to see more outer loop friction points than inner loop. So code reviews, CI, and release processes tend to surface as greater areas of friction than the inner loop.</p>
</blockquote>
<p>We now have the tools to address these outer loop friction points, automating away the steps we know add value but don&rsquo;t enjoy doing. While these tools are still relatively simple, they represent a natural evolution in the AI-driven development era - one that unlocks opportunities far beyond just writing code.</p>
<h2 id="final-thoughts">Final Thoughts</h2>
<p>When I first encountered these terminal-based tools, I couldn&rsquo;t help but wonder if we were taking a step backward. But that initial reaction missed something important: this isn&rsquo;t about the interface - it&rsquo;s about programmability.</p>
<p>Just as git&rsquo;s command-line interface enabled countless automation workflows, these AI assistants can be invoked programmatically to work silently in the background - from reviewing code to generating documentation to managing releases.</p>
<p>This is how evolution often works - not in dramatic leaps, but in subtle shifts that fundamentally change how we work. Software engineering isn&rsquo;t <em>dead</em>, but it is changing. The next step is yours to take: look at your development workflow, identify the friction points, and consider how to weave these capabilities into your pipeline.</p>
]]><![CDATA[<hr><p>Thanks for reading this post via RSS! üëã</p>]]><![CDATA[<a href="mailto:annie.luxton@gmail.com?subject=The Next Evolutionary Step">Reply to this post by email</a>]]></description>
    </item>
    <item>
      <title>You Can‚Äôt Prompt Your Way to Intuition</title>
      <link>http://annievella.com/posts/you-cant-prompt-your-way-to-intuition/</link>
      <pubDate>Fri, 18 Apr 2025 00:00:00 +1300</pubDate><author>annie.luxton@gmail.com (Annie Vella)</author>
      <guid>http://annievella.com/posts/you-cant-prompt-your-way-to-intuition/</guid>
      <description>
      
      
      <![CDATA[<p>We don‚Äôt talk enough about the <em>feeling</em> of learning something deeply - the slow, sometimes frustrating and painful process that forges real intuition.</p>
<p>As software engineers, we know this feeling intimately. The slow burn of mastering a new concept or language. The pressure and anxiety of resolving your first production issue. The endless hours spent debugging a complex system that just won&rsquo;t work - until, at last, it does. And how that struggle itself is the point: it&rsquo;s what transforms a beginner coder into a software engineer with real intuition.</p>
<p>And yet, in the age of AI, that friction is exactly what we&rsquo;re designing away.</p>
<p>GitHub Copilot, ChatGPT, Cursor, Windsurf - they&rsquo;re extraordinary tools. They&rsquo;ve changed the way we work. They accelerate us. They enable us to solve problems we previously would&rsquo;ve struggled with. They&rsquo;re becoming the new normal.</p>
<p>But they also flatten the terrain. And when the terrain is too smooth, we stop noticing what we&rsquo;re stepping over.</p>
<h2 id="the-need-for-speed">The Need for Speed</h2>
<p>As a society, we&rsquo;ve become obsessed with speed. In a world of endless notifications, instant messages, and constant demands for more, we&rsquo;ve normalised a state of perpetual acceleration.</p>
<p>This obsession with speed is especially prevalent in software delivery. In the tech industry, the race to ship new features is relentless. If you&rsquo;re not moving fast, you risk falling behind. Companies compete to launch first, to capture attention, to prove they can outpace the rest. That urgency flows straight to the engineer&rsquo;s desk. We work at a breakneck pace, juggling Slack alerts about pull requests, dashboards updating in real time, CI/CD pipelines demanding ever-faster iterations. We&rsquo;re always looking for ways to do more, faster - to shortcut the things that can be shortcut, to automate the parts that can be automated.</p>
<p>This relentless drive for speed and efficiency has shaped every aspect of how we build software. For decades, we&rsquo;ve chased new ways to get more done: frameworks, libraries, automation scripts, cloud deployments, microservice architectures, new methodologies - each one promising to help us move faster. Now, AI is the latest - and most powerful - shortcut yet. Everywhere you look, people are posting about how much faster they can build software with AI: how many lines of code they&rsquo;ve refactored in a fraction of the time, how much boilerplate they&rsquo;re avoiding with a single prompt, how quickly they&rsquo;re spinning up entire new businesses in a weekend. And yes, that velocity is valuable. Those productivity gains are real - and it‚Äôs changing the landscape.</p>
<h2 id="the-myth-of-the-shortcut">The Myth of the Shortcut</h2>
<p>One of the changes we&rsquo;re seeing is that a new generation of engineers is moving at a pace that would have been unimaginable just a few years ago. Steve Yegge‚Äôs <a href="https://sourcegraph.com/blog/revenge-of-the-junior-developer">Revenge of the Junior Developer</a> captures this shift: junior developers, empowered by AI, are moving faster than ever - sometimes outpacing their more experienced peers. He explains how junior engineers are &lsquo;vibing&rsquo;. They <em>get it</em>. Essentially, AI coding assistants can act as powerful exoskeletons for anyone willing to adapt, enabling them to do work that previously required much more experience.</p>
<p>Shortcuts have their place. They open doors and accelerate growth. But speed doesn&rsquo;t build engineering intuition.</p>
<p>There‚Äôs something disorienting about how good these tools are at helping you <em>sound</em> like an expert. They give you the answers - but they don&rsquo;t teach you how to <em>notice the problem</em> in the first place. And they certainly don&rsquo;t teach you how to trust your instincts.</p>
<p>That‚Äôs the real danger of shortcuts: they make you feel powerful and productive, but can lull you into a false sense of security. Without the intuition and habits forged by experience - knowing when to be wary, when to back up, when to double-check - you&rsquo;re at risk of costly mistakes. These lessons aren&rsquo;t learned by skipping to the answer; they&rsquo;re earned by wrestling with real problems.</p>
<p>Cautionary tales like the one below are popping up everywhere - not necessarily because people lack technical skill, but because they haven&rsquo;t yet built the judgement to anticipate, prevent, or recover from disaster.</p>
<figure class="center"><img src="http://annievella.com/images/ai-destroys-months-of-work.png"
    alt="AI Destroys Months of Work"><figcaption>
      <p><a href="https://www.reddit.com/r/cursor/comments/1inoryp/cursor_fck_up_my_4_months_of_works/">AI Destroys Months of Work</a></p>
    </figcaption>
</figure>

<p>It&rsquo;s not gatekeeping to say that some things still take time. It&rsquo;s just how humans learn.</p>
<p>Santiago Valdarrama‚Äôs blog post <a href="https://www.svpino.com/articles/coding-is-over-now-what/">&ldquo;Coding is over. Now what?&rdquo;</a> points out that as AI commoditises coding, the most valuable skills become things like <em>identifying the right problem, framing it well, and designing elegant, maintainable solutions</em>. But what‚Äôs often glossed over is the uncomfortable reality that these aren&rsquo;t skills you can simply acquire overnight or skip straight to. No one seems to be talking about how the next generation of engineers is supposed to leapfrog past the years of debugging sessions, architectural missteps, and system rewrites that forge true intuition. How do you even know what an elegant, maintainable solution looks like if you&rsquo;ve never had to live with the consequences of a brittle one? These abilities are forged in the messy middle, through friction and deliberate practice - not by shortcutting your way to the answer.</p>
<p>What ties all these higher-order skills together is a kind of engineering intuition - a sense for what matters, what will work, and what might go wrong in different contexts. But intuition isn&rsquo;t something you can prompt for or download; it&rsquo;s earned by moving through the gradual stages of real skill acquisition.</p>
<h2 id="the-dreyfus-model-why-intuition-cant-be-prompted">The Dreyfus Model: Why Intuition Can&rsquo;t Be Prompted</h2>
<p>The Dreyfus Model is one of the best tools I‚Äôve found to help make sense of this journey, both for myself and for others I‚Äôve coached. If you&rsquo;ve never heard of it or how it can be applied to software engineering careers, <a href="https://hackernoon.com/software-engineer-qualification-levels-junior-middle-and-senior-f2229591df1c">this article provides a good overview</a>.</p>
<figure class="center"><img src="http://annievella.com/images/dreyfus-model.png"
    alt="Dreyfus Model of Skill Acquisition"><figcaption>
      <p>The Dreyfus Model of Skill Acquisition</p>
    </figcaption>
</figure>

<p>The model describes five stages, each reflecting a shift in how we use recollection, recognition, decision-making, and awareness.</p>
<ol>
<li><strong>Novice</strong> ‚Äì You follow rules and instructions exactly as given; your recollection and recognition are limited to what you‚Äôve been explicitly taught; you make decisions by following step-by-step guidance; your awareness is focused tightly on the immediate task - bigger-picture context isn‚Äôt relevant (and wouldn‚Äôt help much even if someone tried to give it to you).</li>
<li><strong>Advanced Beginner</strong> ‚Äì You start to recognise recurring patterns and situations; your recollection of similar experiences begins to inform your actions; you still depend on rules but with some flexibility; your awareness starts to expand, but you‚Äôre still mostly focused on the task at hand, with only glimpses of the broader context.</li>
<li><strong>Competent</strong> ‚Äì You can plan, troubleshoot, and prioritise; your recognition of patterns is stronger; you draw on a growing bank of experiences; your decision-making involves conscious choice and analysis; your awareness now includes both immediate tasks and the bigger picture. At this stage, you begin to adapt rules to fit the situation and can finally make use of wider context.</li>
<li><strong>Proficient</strong> ‚Äì You see the big picture and adapt flexibly; your recollection is automatic for most situations; your recognition is rapid and intuitive; your decisions are guided by experience but still involve reflection; your awareness includes anticipating outcomes and adjusting in real time. You often know when to break the rules and why.</li>
<li><strong>Expert</strong> ‚Äì You operate from deep intuition; your recognition and recollection are seamless and often unconscious; you make decisions fluidly, often without deliberate analysis; your awareness is holistic, allowing for creative and adaptive responses. At this level, you‚Äôre often the one creating new rules, patterns, or heuristics for others to follow.</li>
</ol>
<p>The crucial thing is that you can‚Äôt simply skip these stages - no matter how powerful the AI or how quickly you pick up new syntax. Intuition is built by moving through each phase, not by bypassing the messy middle. There‚Äôs a reason it‚Äôs often said that reaching true expertise in any field takes years, not weeks - sometimes a decade or more.</p>
<p>That‚Äôs what I love about the Dreyfus Model: it normalises friction. The path to expertise is supposed to be bumpy. That‚Äôs not a flaw - it‚Äôs a feature, backed by decades of research on skill acquisition and deliberate practice.</p>
<p><a href="https://psycnet.apa.org/doiLanding?doi=10.1037%2F0033-295X.100.3.363">Ericsson et al. (1993)</a> established that expertise isn&rsquo;t simply a function of experience, but of <em>deliberate</em> practice - focused, effortful work aimed at improving specific aspects of performance. Further studies, including <a href="https://dl.acm.org/doi/10.1145/3545945.3569759">Becker et al. (2023)</a>, have explored how these principles apply to programming specifically, showing that enduring mastery requires more than repetition - it requires reflection and productive struggle. This aligns with recent educational research by <a href="https://ieeexplore.ieee.org/document/10213396">Bull and Kharrufa (2024)</a>, who argue that effective learning with AI must integrate human reflection and effort - not bypass it.</p>
<p>This finding is reinforced by an MIT study, as described in Esther Shein&rsquo;s paper <a href="https://dl.acm.org/doi/10.1145/3673428">The Impact of AI on Computer Science Education</a>. In the study, students were split into three groups and given a Fortran task - a language none of them knew. One group used ChatGPT, another used Meta&rsquo;s Code Llama, and a third used only Google. While the ChatGPT group solved the task the fastest, they failed to retain what they had learned and performed poorly in follow-up assessments. The Code Llama group performed slightly better, but the Google group - who had to break the problem down into smaller parts - retained the most and performed best. As the study put it: <em>‚ÄúWorking hard and struggling is actually an important way of learning.‚Äù</em> The results underscore this central claim: that real understanding comes not from being handed solutions, but from working through the friction to reach them.</p>
<p>This matters now more than ever, because AI tools give us fluent syntax and confident answers - but they don&rsquo;t give us the pattern recognition or judgement that only comes from working through the mess.</p>
<h2 id="embrace-the-seams">Embrace the Seams</h2>
<p>Some researchers are starting to recognise this risk and are exploring ways to design AI tools that don‚Äôt just hand you answers, but invite you into the process. <a href="https://ieeexplore.ieee.org/abstract/document/10857384">Inman et al. (2025)</a> at Google call this idea <em>Seamful AI</em>: instead of hiding uncertainty and ambiguity, these tools could surface the ‚Äúseams‚Äù - the places where the answer isn‚Äôt clear-cut, or where multiple paths might be valid.</p>
<p>Why does this matter? Because it‚Äôs in those moments of ambiguity and uncertainty - when you have to pause, weigh options, and make a judgment call - that real learning happens. Exposing the seams doesn‚Äôt just make AI more transparent; it creates space for you to bring your own intuition and critical thinking to the table.</p>
<p>Most AI coding assistants, by contrast, erase those moments. They converge on a single, confident-sounding answer, making it harder to develop real judgment - or even to know that judgment is needed.</p>
<p>We can‚Äôt afford that. Not if we care about software quality. Not if we care about the next generation of engineers.</p>
<h2 id="rediscovering-friction">Rediscovering Friction</h2>
<p>This doesn&rsquo;t mean going back to writing everything from scratch. It means being intentional about when we <em>slow down</em>.</p>
<p>In a world where AI can generate endless code and abstractions pile up faster than ever, friction isn‚Äôt about slogging through every detail. It‚Äôs about choosing your moments. Sustainable, realistic friction is about:</p>
<ul>
<li>Getting curious when something surprises you - whether it‚Äôs a bug, an unexpected result, or a design you don‚Äôt quite trust.</li>
<li>Taking time to understand the systems or components that matter most for your product, your users, or your own growth.</li>
<li>Reflecting on failures and odd behaviours in production, and letting those drive deeper investigation.</li>
<li>Setting aside space for ‚Äúdigging in‚Äù on the areas that spark your curiosity, rather than feeling obligated to master everything.</li>
<li>Sharing what you learn with others - because teaching is one of the best ways to deepen your own understanding.</li>
</ul>
<p>We won&rsquo;t always have the time or energy to read every line, and that&rsquo;s okay. But if we never slow down, never question, never get our hands dirty, we risk losing the intuition that makes us truly effective engineers. Friction, when chosen wisely, is what keeps our skills sharp and our judgement real.</p>
<p>I‚Äôve experienced this firsthand. I still remember becoming obsessed with tracking down a memory leak in production many years ago. The easy fix was already in place - just restart the IIS worker processes every night - but that was a band-aid, not a solution. So I dug in, learning to use WinDbg (a seriously tricky tool to master), poring over cryptic commands and outputs, and chasing down the root cause. It took more time and frustration than I care to admit, but by the end, I didn&rsquo;t just fix the bug - I&rsquo;d become an expert on XML Serialisation (the culprit). That experience didn&rsquo;t just give me an answer; it gave me a kind of intuition that&rsquo;s hard to get any other way.</p>
<p>And yes, maybe today you could ask an AI assistant to help diagnose a memory leak like this. Intuition, though, isn&rsquo;t just about getting the answer, it&rsquo;s about knowing <em>which questions to ask, recognising when something doesn&rsquo;t add up, and having the confidence to dig deeper when a quick fix isn&rsquo;t enough</em>. AI can accelerate learning, and it may help us reach these moments of insight faster than before, but the path taken still matters. The fundamentals - curiosity, persistence, and the willingness to wrestle with problems - are what turn information into real knowledge and meaningful understanding.</p>
<h2 id="the-missing-piece-of-the-conversation">The Missing Piece of the Conversation</h2>
<p>The Dreyfus Model shows us that growth - in any domain, but especially as software engineers - is a journey: slow, sometimes frustrating, often messy. In the age of AI, the path may look different, but the fundamentals haven&rsquo;t changed. Intuition still comes from the same place it always has: deliberate practice, reflection, and time spent wrestling with uncertainty.</p>
<p>And yet, there&rsquo;s something quietly unsettling about the way we&rsquo;re talking about AI right now.</p>
<p>We&rsquo;re told the real value in our work lies in higher-level thinking - identifying the right problems, shaping elegant solutions, seeing the system. And that&rsquo;s true. But what&rsquo;s missing from the conversation is how we can develop those skills when AI is erasing the friction that used to help us build them.</p>
<p><em>If you‚Äôre leading a team</em>, this matters even more. It‚Äôs not just about shipping faster or clearing blockers. It‚Äôs about creating the kind of environment where engineers can still build the instincts and judgment they‚Äôll need later - even if the path to get there looks a little different now.</p>
<p>So use the tools. Embrace the speed. And every so often, slow down - just enough to feel the texture of the work again.</p>
<p>That hard-earned feeling of learning something deeply? It‚Äôs still there. And it still matters.</p>
]]><![CDATA[<hr><p>Thanks for reading this post via RSS! üëã</p>]]><![CDATA[<a href="mailto:annie.luxton@gmail.com?subject=You Can‚Äôt Prompt Your Way to Intuition">Reply to this post by email</a>]]></description>
    </item>
    <item>
      <title>The Software Engineering Identity Crisis</title>
      <link>http://annievella.com/posts/the-software-engineering-identity-crisis/</link>
      <pubDate>Fri, 21 Mar 2025 00:00:00 +1300</pubDate><author>annie.luxton@gmail.com (Annie Vella)</author>
      <guid>http://annievella.com/posts/the-software-engineering-identity-crisis/</guid>
      <description>
      
      
      <![CDATA[<p>Many of us became software engineers because we found our identity in building things. Not managing things. Not overseeing things. <em>Building</em> things. With our own hands, our own minds, our own code.</p>
<p>But that identity is being challenged.</p>
<p>AI coding assistants aren&rsquo;t just changing how we write software - they&rsquo;re fundamentally transforming <em>who we are</em>. We&rsquo;re shifting from creators to orchestrators, from builders to overseers. From engineers to something that looks suspiciously like&hellip; managers.</p>
<p>The irony cuts deep: for years, we&rsquo;ve said that software engineering transcends mere coding. Requirements, design, testing, operations - these were all supposedly part of our craft. Yet the industry pushed us in the opposite direction. We handed these responsibilities to specialists - Product Owners, Architects, Quality Engineers, Platform Engineers - while we doubled down on our coding expertise. We became masters of our code, proud wielders of a modern magic.</p>
<p>And now, just as we&rsquo;ve perfected this craft, AI is threatening to take it away from us.</p>
<h2 id="the-joy-were-about-to-lose">The Joy We&rsquo;re About to Lose</h2>
<p>Let&rsquo;s be honest about what&rsquo;s at stake here. Many of us don&rsquo;t just write code - we <em>love</em> writing code. Our identity is woven into every elegant solution we craft, every test we make pass, every problem we solve through pure logic and creativity. It&rsquo;s not just work, not just a craft - it&rsquo;s who we are.</p>
<p>Think about those moments of deep satisfaction: when you finally track down that elusive bug that&rsquo;s been haunting production, when you work out how to optimise that slow algorithm and watch response times drop from seconds to milliseconds, when you transform a maze of legacy code into something clean and maintainable. These aren&rsquo;t just achievements - they&rsquo;re expressions of who we are as engineers. They&rsquo;re the moments that remind us why we chose this path.</p>
<p>Now imagine AI taking over these moments of craftsmanship. The creators of these tools paint an optimistic picture - they say we&rsquo;ll spend more time on <strong>defining intent</strong>, <strong>high-level architecture</strong>, and <strong>systems thinking</strong>. But listen carefully to what they&rsquo;re really saying: we&rsquo;ll become overseers rather than creators, managers rather than builders.</p>
<figure class="center"><img src="http://annievella.com/images/thomas-dohmke-high-level-architects.png"
    alt="Are software engineers evolving into system thinkers and high-level architects?" width="70%"><figcaption>
      <p><a href="https://www.linkedin.com/posts/ashtom_how-ai-tools-are-reshaping-the-coding-workforce-activity-7303108929264275456-O5v2">Are software engineers evolving into system thinkers and high-level architects?</a></p>
    </figcaption>
</figure>

<p>This shift raises important questions about our identity as builders: Is oversight what drives us? Is it what makes us leap out of bed in the morning, eager to solve the next puzzle?</p>
<h2 id="the-identity-shift-its-already-here">The Identity Shift: It&rsquo;s Already Here</h2>
<p>This isn&rsquo;t some theoretical future we&rsquo;re debating - it&rsquo;s the reality we&rsquo;re living right now. When Google recently revealed that AI <a href="https://arstechnica.com/ai/2024/10/google-ceo-says-over-25-of-new-google-code-is-generated-by-ai/">generates more than a quarter of their new code</a>, it was just the beginning. Y Combinator CEO Garry Tan reveals that for about a quarter of their startups, <a href="https://www.cnbc.com/2025/03/15/y-combinator-startups-are-fastest-growing-in-fund-history-because-of-ai.html">95% of their code is now written by AI</a> - marking a truly significant shift. My own Master&rsquo;s research revealed a similar picture: 77% of us are spending less time writing code, and almost half believe our core skill might become secondary to prompt engineering. Think about that transition: from crafting solutions to crafting prompts.</p>
<figure class="center"><img src="http://annievella.com/images/prompt-engineering-replace-coding-skills.png"
    alt="Will Prompt Engineering Replace Traditional Coding Skills?"><figcaption>
      <p>Will Prompt Engineering Replace Traditional Coding Skills?</p>
    </figcaption>
</figure>

<p>When asked how to develop prompt engineering skills, software engineers emphasise refining communication skills. Getting an AI to do what you want means being able to articulate things well - providing just the right amount of context along with a clear description of the task. The better you can communicate with Gen AI, the more likely the output will match your expectations. Some even suggest being <em>polite</em> to these tools, treating them like team members - as if you&rsquo;re leading another human being to do something for you.</p>
<p>The changes run so deep that we&rsquo;re inventing new terms just to describe who we&rsquo;re becoming. Take <strong>vibe coding</strong>, a term that <a href="https://karpathy.ai">Andrej Karpathy</a> recently coined in a <a href="https://x.com/karpathy/status/1886192184808149383">tweet</a>. It captures a profound shift in how we write software.</p>
<p>At one end of the spectrum lies the traditional way - the craftsperson&rsquo;s way. We write each line with intent, every function name and architectural decision reflecting our deep understanding of the system.</p>
<p>At the other end? We let AI fill in the blanks, &ldquo;vibing&rdquo; with its suggestions. We focus on the what, not the how. As Karpathy puts it: <em>&ldquo;fully give in to the vibes, embrace exponentials, and forget that the code even exists.&rdquo;</em></p>
<p>That last part gives us pause - are we still engineers if we forget all about the code?</p>
<p>In a recent <a href="https://www.youtube.com/watch?v=HtqxI53h7zM">pairing session</a>, engineering thought leaders <a href="https://itrevolution.com/author/gene-kim/">Gene Kim</a> and <a href="https://steve-yegge.medium.com">Steve Yegge</a> demonstrated what this looks like in practice. Using an AI coding assistant, they ported a 3,500-line legacy Ruby script to Kotlin - a task that would normally take a week - in just one hour. The AI didn&rsquo;t just translate the code; it improved it, adding the modular architecture and unit tests they&rsquo;d wanted for years but couldn&rsquo;t justify the time for.</p>
<p>Even <a href="https://www.jedi.be">Patrick Debois</a>, the godfather of DevOps, sees this transformation reshaping our identity. In his <a href="https://ainativedev.io/news/the-4-patterns-of-ai-native-dev-overview">recent analysis of AI Native Development patterns</a>, he outlines four fundamental shifts in how we work:</p>
<figure class="center"><img src="http://annievella.com/images/patrick-debois-four-AI-native-patterns.png"
    alt="Patrick Debois: The 4 Patterns of AI Native Dev"><figcaption>
      <p><a href="https://ainativedev.io/news/the-4-patterns-of-ai-native-dev-overview">Patrick Debois: The 4 Patterns of AI Native Dev</a></p>
    </figcaption>
</figure>

<p>These patterns reveal a profound shift: we&rsquo;re moving from producers to managers of AI systems, from detailed implementation to expressing intent, from delivery to discovery through rapid experimentation, and from content creation to knowledge curation. Our role is evolving to blend creation with orchestration, building with oversight.</p>
<p>Overall, I think it&rsquo;s fair to say that the nature of our professional identity is changing at its core.</p>
<h2 id="the-craft-that-shaped-our-identity">The Craft That Shaped Our Identity</h2>
<p>To understand this identity crisis, we need to look at how deeply the craft of coding has shaped who we are. At its core, writing code is about mastery and control - skills we&rsquo;ve spent years perfecting. Modern programming languages are much higher-level than those of days gone by, but they still require deep technical understanding. Few developers today deal with the nitty-gritty of pointers and memory management, yet we still take pride in knowing how things work under the hood. Even as frameworks do more heavy lifting, we&rsquo;ve maintained our identity as artisans who understand our tools intimately.</p>
<p>Programming today is much more about stitching together APIs, frameworks, and libraries in creative ways to build something meaningful. In fact, recent research at Google suggests that <strong>creativity</strong> in software engineering centres on the concept of <a href="https://ieeexplore.ieee.org/document/10445159">clever reuse over pure novelty</a>. This makes sense to me - I&rsquo;ve often commented that we&rsquo;re all just &lsquo;integration&rsquo; engineers nowadays, really.</p>
<p>Still, there&rsquo;s a strange pride that we take in knowing all the weird syntax required to build something. It&rsquo;s like a secret language that only we understand. Becoming proficient with a programming language gives you a lot of control to make it do precisely what you want it to do. It&rsquo;s so detailed - just one wrong character will break the entire thing and it can take a lot of time and patience to make it do what you want.</p>
<blockquote class="large-quote" style="font-size: 1.5em; margin: 40px; margin-bottom: 0"> First, one must perform perfectly. The computer resembles the magic of legend in this respect, too. If one character, one pause, of the incantation is not strictly in proper form, the magic doesn‚Äôt work.</blockquote>
<p style="margin: 40px; margin-top: 10px; font-size: 0.8em;"><em>‚Äî Frederick P. Brooks, The Mythical Man-Month, Chapter 1, Addison-Wesley, 1975</em></p>
<p>The other 99% of the population thinks we&rsquo;re magicians for understanding code and indeed, it can take years of deliberate practice to master it. Those who master more than one programming language have the privilege of being referred to as <em>polyglots</em>. Many of us take great pride in writing clean, elegant code. We passionately argue over different styles and best practices, often taking it all too seriously.</p>
<h2 id="a-reluctant-managers-tale">A Reluctant Manager&rsquo;s Tale</h2>
<p>Let me share a story about identity evolution that might resonate.</p>
<p>After a decade of being an individual contributor, I hit the infamous ceiling of the technical track. <em>Senior Lead Software Engineer</em> - that was as far as the technical track went. Staff+ Engineering wasn&rsquo;t a thing yet, and the sole Architecture position at the company I was working for was filled. I faced a choice that would change who I was: stay a builder or become an overseer.</p>
<p>I chose management. Reluctantly. That&rsquo;s where the path led me. I told myself it was still engineering, just at a different level. That managing systems wasn&rsquo;t so different from managing people. That I could still keep my hands in the code in between other tasks.</p>
<p>Sound familiar? The parallels are uncanny. Just as I had to trade direct problem-solving for meetings and documentation, we&rsquo;re now being asked to trade coding for prompt engineering. The skills that defined us as engineers - mastering syntax, architecting our code elegantly, catching and handling the edge cases, debugging complex issues - are being relegated to AI. Instead, we&rsquo;re told to focus on skills that sound suspiciously like management: clear communication, systems thinking, problem definition.</p>
<p>But here&rsquo;s what no one&rsquo;s talking about: the identity crisis. That deep sense of loss when you realise you&rsquo;re no longer building things with your own hands. When your technical mastery becomes less relevant than your ability to &ldquo;manage&rdquo; the tools. When your craft becomes oversight.</p>
<p>Can orchestrating AI ever give us that same sense of identity? Of being a builder, a creator, a problem solver?</p>
<h2 id="when-machines-challenge-our-identity">When Machines Challenge Our Identity</h2>
<p>By now the source of our identity crisis becomes clear. The craft we spent years perfecting - the one that gave us purpose, meaning, and pride - is now being done faster, cheaper, and at scale by a machine. Sure, the quality isn&rsquo;t as good as your hand-written code (yet). But the speed at which code can now be written is staggering and businesses are tripping over themselves to get in on the action.</p>
<p>This is where a glimmer of hope emerges. Remember that irony - how we gave away the broader aspects of our craft to specialists? AI is pushing us to reclaim what we once knew: that software engineering transcends mere coding. That core truth remains - ultimately, software engineering is about solving problems, creating solutions, building things that matter.</p>
<p>These broader skills - what Addy Osmani calls &ldquo;durable engineering skills&rdquo; in his article on the <a href="https://addyo.substack.com/p/beyond-the-70-maximizing-the-human">human 30% of AI-assisted coding</a> - have always separated great engineers from good ones. Communication, big-picture thinking, handling ambiguity - these become even more crucial in an AI-driven world.</p>
<p>Yet this emphasis on broader skills has sparked debate in our community. For some, it sounds suspiciously like management repackaged. And they&rsquo;re not entirely wrong - a recent <a href="https://www.cio.com/article/3509174/ai-coding-assistants-wave-goodbye-to-junior-developers.html">CIO article</a> confirms that development teams are already being restructured to focus on oversight rather than creation. The article envisions future teams consisting of a product manager, a UX designer, and a software architect who primarily uses AI to generate prototypes. These architects, or senior developers, must &ldquo;understand the content&hellip; who the customer is and what we&rsquo;re trying to achieve&rdquo; - classic management responsibilities repackaged as technical work.</p>
<figure class="center"><img src="http://annievella.com/images/addy-osmani-durable-engineering-skills.png"
    alt="Management in a Cloak"><figcaption>
      <p>Management in a Cloak</p>
    </figcaption>
</figure>

<p>This evolution raises fundamental questions about our identity as engineers: As the traditional career ladder transforms, how will the next generation of software engineers develop their skills? How do we preserve the deep technical understanding and craftsmanship that shaped our profession while embracing these new tools? And perhaps most unsettling - as AI capabilities advance exponentially, will our role as craftspeople become as obsolete as the manual weaver&rsquo;s did during the Industrial Revolution?</p>
<h2 id="the-path-forward">The Path Forward</h2>
<p>Perhaps the answer lies not in resisting this transformation, but in understanding it through the lens of history. These identity crises - these fundamental shifts in how we define ourselves through our work - aren&rsquo;t new. They&rsquo;re part of a pattern that repeats whenever technology reshapes a profession.</p>
<p>During the <a href="https://www.britannica.com/story/the-rise-of-the-machines-pros-and-cons-of-the-industrial-revolution">Industrial Revolution</a>, craftspeople faced a similar crisis. Their traditional skills - honed over generations - were being replaced by machines. But what happened next is fascinating: many adapted, becoming specialist professionals who could fix and improve these same machines that threatened to replace them. Others found ways to apply their deep understanding of materials and processes to improve overall factory operations.</p>
<p>If we draw this parallel to our AI era, a similar path emerges. The core of software engineering - solving problems and creating value - remains unchanged. Our tools are evolving, and with them, the skills needed to wield them effectively.</p>
<p>The question isn&rsquo;t whether we&rsquo;ll become managers of machines - it&rsquo;s whether we can find the same satisfaction in this evolution of our craft.</p>
<h2 id="the-engineers-dilemma">The Engineer&rsquo;s Dilemma</h2>
<p>So where does this leave us? Are we all destined to become overseers of AI agents rather than writers of code? Is this a future to resist or embrace?</p>
<p>The truth, as always, is nuanced. Just as some engineers naturally gravitate toward management while others prefer to remain hands-on, we&rsquo;ll likely see a similar spectrum emerge in how we interact with AI. Some will excel at orchestrating AI systems, focusing on high-level design and making these systems more efficient and reliable - conducting a technical symphony rather than performing solo. Others will find their calling in domains where human expertise remains crucial - perhaps in security-sensitive applications, novel areas where AI lacks training data, or systems where performance and reliability are paramount. The key isn&rsquo;t to resist this evolution, but to find our place within it.</p>
<p>What&rsquo;s clear is that the definition of &ldquo;software engineer&rdquo; is expanding, not contracting. The skills that make someone valuable are diversifying. And this creates both challenges and opportunities.</p>
<p>For those who love the craft of coding, this shift can feel threatening. But remember that AI tools are still just that - tools. They don&rsquo;t understand the &ldquo;why&rdquo; behind the code, the business context, or the human needs being served. They can&rsquo;t innovate in the true sense of the word, at least not yet. And as far as we know, they can&rsquo;t <em>feel the satisfaction</em> of solving a complex problem or the joy of creating something new.</p>
<p>Perhaps the most valuable skill in this new landscape isn&rsquo;t prompt engineering or systems architecture, but <strong>adaptability</strong> - the willingness to evolve, to learn new skills, and to find your unique place in a rapidly changing field.</p>
<h2 id="the-bright-side">The Bright Side</h2>
<p>Despite these challenges, there&rsquo;s something important we need to acknowledge: these AI tools can be incredibly empowering. With agentic IDEs like <a href="https://codeium.com/windsurf">Windsurf</a> and <a href="https://www.cursor.com">Cursor</a> taking software development to a whole new level, it&rsquo;s like having a supportive pair-programming partner who&rsquo;s always there, ready to help you tackle problems that might have seemed daunting before.</p>
<p>For junior developers or those of us who might feel a bit rusty, AI assistants can be a confidence booster - helping you get started when you&rsquo;re staring at a blank file, validating your approach when you&rsquo;re unsure, or explaining complex concepts in a way that makes sense to you. For experienced developers, they&rsquo;re like having a tireless assistant who can handle the routine tasks while you focus on the more challenging aspects of the problem.</p>
<p>The speed at which we can now prototype ideas, explore different approaches, and learn new technologies is truly remarkable. What might have taken weeks of research and trial-and-error can often be accomplished in hours or even minutes. It&rsquo;s like having a superpower - the ability to amplify our capabilities and turn our ideas into reality faster than ever before.</p>
<h2 id="the-reality-check">The Reality Check</h2>
<p>But with great power comes great responsibility. A recent comprehensive <a href="https://arc.dev/talent-blog/impact-of-ai-on-code/">GitClear study</a> analysing 211 million lines of code revealed some concerning trends as AI code generation tools became more prevalent:</p>
<ul>
<li>A 17.1% increase in copy-pasted code, marking the first time AI-assisted code duplication surpassed refactored (moved) code.</li>
<li>An 8-fold rise in duplicated code blocks, with 6.66% of commits now containing repeated code sections.</li>
<li>A 26% increase in code churn, with 5.7% of all code changes being revised or deleted within two weeks.</li>
</ul>
<figure class="center"><img src="http://annievella.com/images/gitclear-2025-trends-in-code-changes.png"
    alt="GitClear: Trends in Code Changes"><figcaption>
      <p><a href="https://arc.dev/talent-blog/impact-of-ai-on-code/">GitClear: Trends in Code Changes</a></p>
    </figcaption>
</figure>

<p>While we&rsquo;re producing code faster than ever, we&rsquo;re also spending more time fixing AI-generated mistakes and dealing with code that&rsquo;s harder to maintain. This isn&rsquo;t just about speed - it&rsquo;s about the craft of writing sustainable, maintainable software.</p>
<h2 id="the-hidden-identity-crisis">The Hidden Identity Crisis</h2>
<p>Yet beneath these surface-level changes lies a deeper challenge - one that strikes at the heart of who we are as engineers. The emerging field of Human-AI teaming is revealing uncomfortable truths about our future. A <a href="https://www.sciencedirect.com/science/article/pii/S2352250X24000502">2024 study</a> shows that when humans and AI work together, the results often fall short of expectations. Not because AI lacks capability, but because trust works differently with machines than with humans.</p>
<p>We don&rsquo;t build trust with AI the way we do with human teammates.</p>
<p>With humans, trust grows gradually, through shared success. Each problem solved together strengthens the bond. Even failures can deepen trust when handled well. With AI, trust often starts high and erodes fast.</p>
<p>Every incorrect response, every hallucinated bug fix, every misplaced confidence weakens our faith in the machine. Unlike human relationships where trust typically grows over time, AI trust often peaks early and declines.</p>
<p>And when trust erodes, so does productivity.</p>
<p>The research reveals why:</p>
<ul>
<li>There&rsquo;s an inherent unpredictability in how AI interprets our intentions</li>
<li>It lacks the contextual awareness that makes human collaboration fluid</li>
<li>Its decisions often lack transparency, making it hard to rebuild trust once lost</li>
</ul>
<p>These challenges mirror what many of us experience when transitioning into technical leadership. Just as new engineering managers must learn to trust their team&rsquo;s work without doing it themselves, we now face a similar transition with AI - learning to guide and verify rather than write every line ourselves.</p>
<p>The reality is stark: despite AI&rsquo;s raw capabilities, teams often perform worse with AI than without it. Just as a team&rsquo;s productivity suffers under ineffective leadership, our effectiveness diminishes when we don&rsquo;t understand how to work with our AI tools.</p>
<h2 id="reclaiming-your-identity">Reclaiming Your Identity</h2>
<p>Drawing from both my journey as a reluctant manager and my research into this AI transformation, I see three ways we might preserve our identity as builders:</p>
<ol>
<li><strong>Resist</strong> - Some will choose to focus on domains where human creativity and deep technical expertise remain essential</li>
<li><strong>Adapt</strong> - Others will embrace AI orchestration, becoming conductors of a new kind of technical symphony</li>
<li><strong>Balance</strong> - And many, like myself, will seek a middle path - using AI for routine tasks while preserving the joy of direct problem-solving</li>
</ol>
<p>Then I had a realisation that changed my perspective: <em>We don&rsquo;t have to choose just one path</em>.</p>
<h2 id="the-identity-pendulum">The Identity Pendulum</h2>
<p>Perhaps the answer to our identity crisis lies in the <a href="https://charity.wtf/2017/05/11/the-engineer-manager-pendulum/">Engineer/Manager pendulum</a>. My own journey between these roles taught me something crucial about identity:</p>
<ul>
<li>Management didn&rsquo;t replace my engineering identity - it expanded it</li>
<li>Returns to hands-on work weren&rsquo;t steps backward - they were identity renewals</li>
<li>The pendulum swing itself became part of who I am - adaptable, growing, evolving</li>
</ul>
<p>And that&rsquo;s when it hit me: <em>This is exactly the model we need for the AI age</em>.</p>
<p>Instead of being forced into permanent &ldquo;AI managers,&rdquo; what if we could swing between:</p>
<ul>
<li>Deep technical work where we write and refine code directly</li>
<li>Strategic orchestration where we guide AI systems</li>
<li>Creative problem-solving that combines both approaches</li>
</ul>
<p>This balanced approach resonates deeply with what I&rsquo;m hearing from fellow engineers. My research shows a clear message: maintaining strong engineering fundamentals is more crucial than ever. We need deep technical knowledge to effectively review, verify, and adjust AI-generated code - because it&rsquo;s often not quite right. When asked about their concerns with AI coding assistants, software engineers ranked code quality and security well above job security.</p>
<figure class="center"><img src="http://annievella.com/images/ai-concerns.png"
    alt="Top Concerns About AI Coding Assistants"><figcaption>
      <p>Top Concerns About AI Coding Assistants Among Software Engineers</p>
    </figcaption>
</figure>

<p>That tells me something profound: we see ourselves as guardians of engineering excellence, ensuring that AI-generated solutions adhere to solid software engineering principles. We&rsquo;re not looking to delegate our expertise to AI - we&rsquo;re evolving to apply our craft in new ways.</p>
<h2 id="your-move">Your Move</h2>
<p>As we navigate this transformation, a fundamental truth emerges: our identity crisis isn&rsquo;t really about AI at all. The research into Human-AI teaming, the parallels with management transitions, the pendulum of roles - they all point to something deeper. Beyond choosing between builder or overseer lies the heart of who we are: creators.</p>
<p>And now we come full circle: AI isn&rsquo;t taking our jobs; it&rsquo;s giving us a chance to reclaim those broader aspects of our role that we gave away to specialists. To return to a time when software engineering meant more than just writing code. When it meant understanding the whole problem space, from user needs to business impact, from system design to operational excellence.</p>
<p>The pendulum metaphor offers us wisdom here. Just as many of us have swung between engineering and management roles, we can embrace a similar fluidity with AI. Some periods we&rsquo;ll dive deep into the code, experiencing that thrill of crafting elegant solutions. Other times we&rsquo;ll step back to guide AI systems - not as overseers, but as master builders who understand every part of their craft. Like the Industrial Revolution&rsquo;s workers who became experts at optimising the machines that transformed their craft, we can master these AI systems - making them instruments of our creativity, not replacements for it.</p>
<p>In the AI era, what matters most is preserving the essence of who we are: that pure joy of building things, of solving hard problems, of making something work exactly right. Our engineering excellence runs deeper than just verifying AI&rsquo;s work - it flows from knowing systems so intimately that we can shape them, improve them, transform them.</p>
<p>The choice isn&rsquo;t whether AI will change our industry - it already is. The real choice is how we evolve with it. Will we cling to an outdated sense of what it means to be an engineer? Or will we reclaim our craft, not as mere coders, but as master builders of AI-augmented systems?</p>
<p>The pendulum is swinging - will you hold your ground, or move with it?</p>
]]><![CDATA[<hr><p>Thanks for reading this post via RSS! üëã</p>]]><![CDATA[<a href="mailto:annie.luxton@gmail.com?subject=The Software Engineering Identity Crisis">Reply to this post by email</a>]]></description>
    </item>
    <item>
      <title>Rediscover the Power of Simplicity</title>
      <link>http://annievella.com/posts/rediscover-the-power-of-simplicity/</link>
      <pubDate>Sat, 01 Mar 2025 00:00:00 +1300</pubDate><author>annie.luxton@gmail.com (Annie Vella)</author>
      <guid>http://annievella.com/posts/rediscover-the-power-of-simplicity/</guid>
      <description>
      
      
      <![CDATA[<p>In an era where tech stacks grow ever more complex and teams become increasingly specialised, there&rsquo;s profound wisdom to be found in looking back at simpler, more effective approaches.</p>
<p>I&rsquo;ve been meaning to write about my experience at <a href="https://www.trademe.co.nz/">Trade Me</a> for years. Earlier this week, I attended the launch of <a href="https://rowansimpson.com">Rowan Simpson</a>&rsquo;s new book, <a href="https://howtobewrongbook.com">How to Be Wrong</a>. Rowan hired me into his team at Trade Me back in 2006, and to my delight, I even earned a mention in his book! That unexpected recognition, along with recently reading <a href="https://teamtopologies.com/industry-examples/trade-me-journey-towards-a-thinnest-viable-platform">this article</a> about Trade Me&rsquo;s journey toward a &ldquo;thinnest viable platform&rdquo;, finally motivated me to reflect on what remains one of my best professional experiences to this day.</p>
<p>For those unfamiliar, Trade Me is an online marketplace - New Zealand&rsquo;s version of eBay. In the early 2000s, it was the go-to online marketplace for Kiwis, long before global platforms like Facebook Marketplace or AliExpress were established. Trade Me isn&rsquo;t just an auction site - it&rsquo;s a cornerstone of Kiwi internet culture, connecting buyers and sellers across the country and becoming an essential part of daily life for millions.</p>
<figure class="center"><img src="http://annievella.com/images/trademe-2007.png"
    alt="Trade Me in 2007 (courtesy of the [Internet Archive](https://archive.org))"><figcaption>
      <p>Trade Me in 2007 (courtesy of the <a href="https://archive.org">Internet Archive</a>)</p>
    </figcaption>
</figure>

<p>Reflecting on my time at Trade Me has me thinking about something I consider often: <strong>the power of simplicity in building effective systems and how much we can learn from those simpler times</strong>.</p>
<h3 id="the-system-that-worked">The System That Worked</h3>
<p>Despite the modest size of the company, when I worked at Trade Me in 2006-07, the platform was operating at a scale that many would find daunting even today: over 3.4 million active registered members (equivalent to 75% of New Zealand&rsquo;s population at the time) and up to 60,000 users online during peak hours. This was no small feat for the infrastructure of the time, and it was a testament to the simplicity and efficiency of the systems we built.</p>
<p>Working at Trade Me was an incredible experience. Building a web app that millions of people used daily was exhilarating. Trade Me is such a beloved and recognisable brand that wearing the company t-shirt felt like a badge of honour. It was at Trade Me that I learned how to build and ship features that customers loved, and for me, it remains one of the best, most effective examples of how to do it right. <a href="https://deming.org">W. Edwards Deming</a> would have been proud of our approach - we were like &ldquo;The Little Team That Could&rdquo; - tackling challenges with enthusiasm and a sense of fun that made even the toughest problems seem solvable when approached with the right mindset.</p>
<p>The development team was tiny - just six software engineers, supported by a handful of DBAs, sys admins, and testers - yet we delivered an astonishing amount of work with a pace and quality that feels almost mythical compared to modern standards. There was one designer and no formal product management layer - ideas and direction came straight from <a href="https://en.wikipedia.org/wiki/Sam_Morgan_(entrepreneur)">Sam Morgan</a> (the founder and CEO), Jessi Morgan and Rowan Simpson, flowing directly to those building the features.</p>
<p>We didn&rsquo;t have the sophisticated tools or complex architectures we see today. There was no Jira, no CI/CD pipelines as we know them now, no automated testing, no cloud services, and no microservices. Trade Me was a monolithic web app written in ASP. We were migrating it to ASP.NET gradually - every page we touched had to be split into frontend and code-behind files. Deployments were automated through a custom tool: zip up the application, copy it to load-balanced web servers, unzip it, and restart IIS app pools. And yet, despite - or perhaps because of - this simplicity, we deployed to production <strong>twice daily</strong> (except for Friday afternoons which were reserved for socialising) with very few exceptions or incidents.</p>
<p>Looking back, I believe that success was driven by the &ldquo;system&rdquo; of how we worked. The team structures, culture, and decision-making processes were all incredibly well-aligned. This alignment also influenced the technical architecture, which was simple, efficient, and easy to maintain. The simple monolithic architecture, that powered a web app used by 75% of New Zealand&rsquo;s population, was a direct result of our organisational structure and the way we worked, not the other way around.</p>
<h3 id="conways-law-and-our-bias-for-addition">Conway&rsquo;s Law and Our Bias for Addition</h3>
<p>Look at any modern tech organisation chart and you&rsquo;ll see a dizzying array of specialised roles: Frontend Engineers, Backend Engineers, Fullstack Engineers, Mobile Engineers, <em>Product Engineers</em>, DevOps Engineers, Site Reliability Engineers, Platform Engineers, Data Engineers, Quality Engineers, Business Analysts, Product Owners, Scrum Masters, Agile Coaches, Delivery Leads&hellip; the list goes on. Now look at their <strong>system architecture diagrams</strong> - they&rsquo;re often just as complex.</p>
<p>This isn&rsquo;t a coincidence. <a href="https://en.wikipedia.org/wiki/Conway%27s_law">Conway&rsquo;s Law</a> tells us that <em>organisations design systems that mirror their communication structures</em>. At Trade Me, the simplicity of our organisational structure directly influenced the simplicity of our software systems. With just six engineers, a few DBAs, sys admins and testers, and one designer, our communication paths were clear and direct, and the systems we built were just as straightforward.</p>
<p>Today, we often justify our complex organisational structures as necessary for &ldquo;scaling&rdquo; or &ldquo;specialisation&rdquo;. But what if we&rsquo;re getting it backwards? What if our <strong>complex systems are a result of our complex organisations</strong>, rather than the other way around?</p>
<p>There&rsquo;s another factor at play here: <strong>our brains are wired to solve problems by adding, not subtracting</strong>.</p>
<p>A <a href="https://www.sciencealert.com/here-s-why-our-brains-always-want-to-solve-problems-by-adding-not-taking-away">study of 1,585 people</a> found that humans default to addition when addressing challenges, often without even considering subtraction. This cognitive bias manifests in countless ways: more meetings, more tools, more processes, more people, more systems, more code. It&rsquo;s no surprise that over time, our software systems have become increasingly complex - layer upon layer added in the pursuit of better outcomes.</p>
<p>At Trade Me, we didn‚Äôt have the luxury of adding endlessly. Limited resources and small team sizes forced us to think differently, often leading to pragmatic and simple yet elegant solutions. By keeping the system simple, we avoided the pitfalls of ‚Äúmore is better‚Äù thinking and achieved results that, ironically, were better because they were simpler.</p>
<h3 id="what-made-it-work">What Made It Work?</h3>
<p>So, what about the &ldquo;system&rdquo; at Trade Me made it so successful? Here are a few observations:</p>
<ul>
<li>
<p><strong>Clear Ownership and Accountability</strong> - Each project was run by a small, cross-functional team with clear responsibilities. Each software engineer was given an opportunity to lead a project, regardless of their seniority. They got to choose their teams, and were trusted to deliver. This trust fostered ownership, pride, and accountability, and allowed us to experience what it meant to lead a software team (which I think is <em>really important</em> but a topic for another post). Much of this culture was driven by leaders like Rowan, whose vision and focus on getting the fundamentals right played a big part in creating an environment where simplicity thrived.</p>
</li>
<li>
<p><strong>Small, Focused Teams</strong> - Projects were staffed with just enough people - a couple of software engineers, a DBA, a sys admin if needed, and a tester. The small size forced focus and collaboration, and the simplicity of the structure kept communication overhead low.</p>
</li>
<li>
<p><strong>Pragmatism Over Perfection</strong> - We delivered value quickly and iterated as needed, avoiding over-engineering and staying focused on what truly mattered.</p>
</li>
<li>
<p><strong>Continuous Deployment Culture</strong> - Deploying to production twice daily created a feedback loop that allowed us to learn and adjust rapidly. It was an early version of the DevOps as we know it today, and it worked because we kept it simple.</p>
</li>
<li>
<p><strong>Direct Customer Insight</strong> - Many of our testers had come from customer support roles and deeply understood the end users. This close connection to the end user meant that what we built was always grounded in real needs.</p>
</li>
</ul>
<h3 id="what-can-we-learn-today">What Can We Learn Today?</h3>
<p>The Trade Me of the mid-2000s thrived on simplicity, pragmatism, and alignment. Today, we‚Äôre surrounded by tools, frameworks, and architectural patterns that promise to make our work easier, but instead, they often add complexity. So how can we apply the lessons of Trade Me to modern software development?</p>
<ul>
<li>
<p><strong>Focus on the System, Not Just the Tools</strong> - Fancy tools and microservices won&rsquo;t save you if your organisational system is broken. Start by defining a clear purpose and aligning teams, roles, and communication structures.</p>
</li>
<li>
<p><strong>Embrace Simplicity</strong> - Keep simplicity at the heart of your decision-making. Sometimes, the simplest solution is the best one - not every problem requires a new complex process, framework or tool. Ask yourself, &ldquo;What is the simplest way to achieve the desired outcome without adding unnecessary overhead?&rdquo;. Simplicity and pragmatism ensures your systems remain efficient, understandable, and maintainable over time.</p>
</li>
<li>
<p><strong>Enable Small, Cross-Functional Teams</strong> - Small teams with end-to-end ownership are still the best way to build software. Ensure they have the right capabilities and context, then empower them with agency and accountability. Crucially, ensure that software engineers are not just participants but <em>leaders in this process</em>. They are the ones with the technical expertise to make informed decisions on how to build the thing so their perspective matters, a lot.</p>
</li>
<li>
<p><strong>Streamline Feedback Loops</strong> - Shorten the time between idea and delivery. Whether it&rsquo;s through CI/CD or daily deployments, keep your deployments small and often. Address small issues before they become big ones.</p>
</li>
<li>
<p><strong>Bring Back the Generalist</strong> - As specialisation increases, we lose the magic of software engineers who can see and build the whole picture. Let&rsquo;s rediscover the value of being a &ldquo;full-stack&rdquo; team member. The rise of AI tools could really help here, making it easier for engineers to learn how to work effectively across different technologies and domains.</p>
</li>
</ul>
<p><strong>This last point is particularly relevant in our AI-driven future.</strong> While AI coding assistants are making it easier than ever to generate specialised code, they&rsquo;re simultaneously lowering the barriers to becoming a true generalist. With AI handling the syntax and implementation details, engineers can focus more on the holistic understanding of systems and user needs ‚Äì precisely the kind of thinking that made Trade Me so successful.</p>
<h3 id="final-thoughts">Final Thoughts</h3>
<p>Trade Me&rsquo;s approach to building software in the mid-2000s was remarkable because it was so simple and it worked so well. Our little team accomplished things that seemed impossible given our size, proving that with the right approach, small teams can achieve outsized results. Our <em>system</em> was capable of achieving incredible outcomes. By understanding the system as a whole and keeping things simple, we delivered exceptional quality with minimal resources.</p>
<p>Today, as we navigate ever-growing complexity in software development, perhaps it&rsquo;s time to revisit those principles. Let&rsquo;s simplify. Let&rsquo;s align. Let&rsquo;s recapture that spirit of small teams doing big things. Let&rsquo;s build systems that enable us to do our best work, not just add layers of abstraction.</p>
<p>The question I leave you with is this: <strong>What would happen if you thoughtfully simplified the unnecessary complexity in your organisation and systems?</strong> What if, instead of adding more specialists, more processes, more tools, you focused on building a simpler, more aligned system where small teams could thrive? The results might surprise you.</p>
<p>The tools have changed, but the principles remain timeless. <strong>It&rsquo;s time to rediscover the power of simplicity</strong>.</p>
]]><![CDATA[<hr><p>Thanks for reading this post via RSS! üëã</p>]]><![CDATA[<a href="mailto:annie.luxton@gmail.com?subject=Rediscover the Power of Simplicity">Reply to this post by email</a>]]></description>
    </item>
    <item>
      <title>The SDLC Strikes Back: Adapting to AI-Driven Development</title>
      <link>http://annievella.com/posts/the-sdlc-strikes-back/</link>
      <pubDate>Fri, 07 Feb 2025 00:00:00 +1300</pubDate><author>annie.luxton@gmail.com (Annie Vella)</author>
      <guid>http://annievella.com/posts/the-sdlc-strikes-back/</guid>
      <description>
      
      
      <![CDATA[<p>Earlier this year, <a href="https://lovable.dev">Lovable</a> celebrated their biggest milestone yet - more than 12,000 (!) new projects created in a single day. The very next day, they went down. The irony? Their success became their downfall. Each new project in Lovable requires a new GitHub repository, and this surge - thousands per day - put such strain on GitHub&rsquo;s infrastructure that it risked affecting GitHub&rsquo;s entire platform. Their on-call engineer had to make the difficult decision to suspend Lovable&rsquo;s account, effectively blocking all users from creating or editing their projects.</p>
<figure class="center"><img src="http://annievella.com/images/lovable-github-incident.png"
    alt="Lovable Dev GitHub Incident" width="75%"><figcaption>
      <p><a href="https://x.com/antonosika/status/1876342499620667511">Anton Osika - Lovable Dev GitHub Incident</a></p>
    </figcaption>
</figure>

<p>This incident perfectly illustrates a fundamental principle of systems thinking: when you push hard on one part of a complex system, it pushes back in unexpected ways. <a href="https://en.wikipedia.org/wiki/Peter_Senge">Peter Senge</a> captured this insight in <a href="https://en.wikipedia.org/wiki/The_Fifth_Discipline">The Fifth Discipline</a> as one of his laws of systems thinking: <strong>the harder you push, the harder the system pushes back</strong>.</p>
<p>The Software Development Lifecycle (SDLC) is one such complex system, and right now, we&rsquo;re pushing on it harder than ever before. If you&rsquo;re working with AI tools, you&rsquo;ve probably experienced this yourself - code that used to take hours or days to write is now generated in seconds. &ldquo;The code just writes itself now!&rdquo; has become a common refrain in development circles. And while it&rsquo;s not entirely wrong, it&rsquo;s making us face some fascinating challenges.</p>
<p>What happens when code generation is no longer the bottleneck? Here&rsquo;s what you&rsquo;ll start seeing: larger PRs piling up in review queues, test suites taking longer to run, and deployments struggling to keep up. As we accelerate one part of the development cycle, the system inevitably responds in ways that demand our attention - and you&rsquo;ll need to be ready.</p>
<h2 id="pipeline-pressure-points">Pipeline Pressure Points</h2>
<p>As we accelerate code generation with AI, we&rsquo;re seeing the system push back at both ends of our development pipeline - both before and after the actual build phase.</p>
<h3 id="ux-the-pre-build-bottleneck">UX: The Pre-Build Bottleneck</h3>
<p>Software development has always been constrained by implementation speed. Even at the 1968 conference where the term &ldquo;Software Engineering&rdquo; was coined, the word &ldquo;cost&rdquo; appears <strong>96 times</strong> <a href="https://www.scrummanager.com/files/nato1968e.pdf">throughout the report</a> - and they weren&rsquo;t just talking about hardware. Despite decades of new methodologies, frameworks, and automation tools, writing code has remained stubbornly time-consuming.</p>
<p>But AI coding assistants are changing this equation dramatically. Tasks that used to take days - like scaffolding new APIs, building authentication systems or perfecting UI layouts - now take hours or minutes. The implementation speed that has bottlenecked our industry for decades is suddenly dramatically increasing.</p>
<p>And that&rsquo;s when a new challenge emerges. I recently came across this <a href="https://www.reddit.com/r/ChatGPTCoding/comments/1h26x0k/team_transitioned_to_cursor_but_bottleneck_is_now/">Reddit post</a> that hints at what&rsquo;s coming:</p>
<figure class="center"><img src="http://annievella.com/images/cursor-speed-ux-bottleneck.png"
    alt="Reddit post - Team transitioned to Cursor but bottleneck is now UX"><figcaption>
      <p><a href="https://www.reddit.com/r/ChatGPTCoding/comments/1h26x0k/team_transitioned_to_cursor_but_bottleneck_is_now/">Reddit post - Team transitioned to Cursor but bottleneck is now UX</a></p>
    </figcaption>
</figure>

<p>While most teams are still focused on adopting AI for faster code generation, some early adopters are already hitting a different wall: they can implement features faster than they can design them. The bottleneck is shifting from implementation to conception - from <em>how</em> to build it to <em>what</em> to build.</p>
<p>This is systems thinking in action - as we optimise one part of the pipeline, we&rsquo;re exposing constraints elsewhere. Soon, our biggest challenge won&rsquo;t be writing code, but rather understanding user needs, designing intuitive interfaces, and crafting requirements that actually solve real problems. We&rsquo;re going to need new ways to accelerate these early stages of development to keep pace with our AI-enhanced implementation capabilities.</p>
<h3 id="the-speed-wobbles-post-build-challenges">The Speed Wobbles: Post-Build Challenges</h3>
<p>Remember learning to ride a bike? There&rsquo;s that terrifying moment when you&rsquo;re going so fast that the handlebars start to shake. You&rsquo;re not doing anything wrong - you&rsquo;ve just hit that speed where everything starts to wobble. That&rsquo;s exactly what&rsquo;s happening in our development pipelines.</p>
<p>The ripple effects of accelerated code generation are showing up in unexpected places. As mentioned in a <a href="https://annievella.com/posts/what-its-really-like-using-an-ai-coding-assistant/">previous post</a>, the <a href="https://dora.dev/research/2024/dora-report/">2024 DORA Report</a> revealed a fascinating paradox: while AI tools are improving many of the things we typically associate with better delivery - documentation quality, code quality, code review speed, and reduced complexity - the industry is actually seeing a decline in overall delivery performance.</p>
<p>This highlights another key principle of systems thinking: improving individual components doesn&rsquo;t necessarily improve the system as a whole. In fact, it can make things worse if those improvements aren&rsquo;t balanced across the entire pipeline. The DORA findings suggest that our development processes, built and optimised over decades for human-speed code generation, need fundamental rethinking to handle the velocity that AI enables.</p>
<h2 id="adapting-to-ai-driven-development">Adapting to AI-Driven Development</h2>
<p>As these pressure points emerge, we&rsquo;re seeing new tools and practices evolve to help us adapt. These adaptations focus on two key areas: how we provide context to our AI tools, and how we think about our source artifacts themselves.</p>
<h3 id="the-importance-of-context">The Importance of Context</h3>
<p>Here&rsquo;s a scenario every developer knows too well: you&rsquo;re working with a new teammate, and they ask you how to use the company&rsquo;s internal authentication library. You point them to the documentation, only to realise it&rsquo;s woefully outdated. So you spend the next hour walking them through the codebase, explaining the patterns, the gotchas, and trying to recall why certain decisions were made.</p>
<p>Now imagine having this same conversation with an AI coding assistant. Without proper context, it&rsquo;s just as lost as that new teammate. Sure, it can write decent code from simple prompts, but ask it to work with your custom libraries or follow your team&rsquo;s patterns that it can&rsquo;t possibly know anything about, and it&rsquo;s flying blind.</p>
<p>This is why we&rsquo;re seeing tools like <a href="https://llmcontext.com">LLMContext.com</a> and <a href="https://www.uithub.com">Uithub.com</a> emerge. These tools create rich, interpretable context files from your entire development ecosystem. Not just source code, but documentation in various formats - from Markdown files to PDFs, and even content from images and other media (thanks to Microsoft&rsquo;s <a href="https://github.com/microsoft/markitdown">MarkItDown</a> tool).</p>
<p>It&rsquo;s like giving your AI assistant the equivalent of that hour-long walkthrough. Now when you ask it to add a feature using your authentication library, it understands the patterns, the constraints, and the team conventions. The code it generates isn&rsquo;t just syntactically correct - it feels like it was written by someone who actually knows your codebase.</p>
<p>This emerging need for rich, well-structured context is yet another way the SDLC is pushing back. As our AI tools get better at writing code, we need better ways to help them understand <em>our</em> code.</p>
<h3 id="are-specs-and-prompts-our-new-source-code">Are Specs and Prompts our New Source Code?</h3>
<p>Perhaps the most fundamental adaptation is in how we think about source code itself. When we were writing code by hand (wow, that feels weird to say), the most important thing to store safely was the source code. It&rsquo;s in the name - <em>source</em>. From that, you should be able to derive everything else you need to know about how the system ought to operate.</p>
<p>The reality is that we&rsquo;re not writing all the code by hand anymore. Instead, we&rsquo;re writing specifications and prompts for AI coding assistants to <em>generate</em> code for us. And this raises an important question: if all you&rsquo;re storing is the generated output of the LLMs, isn&rsquo;t that almost the equivalent of only storing compiled code (bytecode, IL, binaries) instead of the source code?</p>
<p>We&rsquo;re not in entirely new territory here. Test-Driven Development (TDD) and Behaviour-Driven Development (BDD) have long emphasized the importance of capturing the <em>intent</em> behind our code - TDD through tests, BDD through behaviour specifications. Both approaches ensure we&rsquo;re clear about what we want before we build it. The same principle applies here - without capturing our intent, we&rsquo;re just hoping the implementation does what we think it was intended to do.</p>
<p>The rise of AI-generated code raises interesting questions about code understanding. As AI generates more of our code, some worry we&rsquo;ll lose our grasp on how it all works. But maybe that&rsquo;s looking at it wrong - if we can capture and validate our intent clearly enough, debugging might become less about understanding the implementation and more about refining the specification. Think of it as hitting replay with a slightly modified script.</p>
<p>Following this line of thinking to its natural conclusion - if prompts and specifications are becoming our new source code, shouldn&rsquo;t we treat them with the same care and organisation? Just as we&rsquo;ve developed sophisticated ways to store, manage and share code, we need new tools and practices for managing our AI interactions. Here are three ideas that are already starting to emerge:</p>
<h3 id="1-prompt-libraries">1. Prompt Libraries</h3>
<p>Remember when we used to stash away useful code snippets? Those bits of tried-and-tested code that we&rsquo;d copy-paste into new projects? For me it was SQL - I couldn&rsquo;t help but keep almost every piece of SQL I ever wrote in a folder because you just never knew when it was going to come in handy again!</p>
<p>Well, welcome to the AI era&rsquo;s equivalent: <strong>Prompt Libraries</strong>. Instead of storing code in repos, we&rsquo;re now starting to store and share the prompts that consistently generate good outputs. We&rsquo;re already seeing this materialize in practice - a recent <a href="https://dev.to/portkey/three-prompt-libraries-you-should-know-as-a-ai-engineer-32m8">article on dev.to</a> highlights several emerging prompt libraries that are bringing engineering rigor to prompt creation and management.</p>
<p>Imagine having a library of prompts that you know will generate a solid REST API endpoint, complete with error handling and input validation. Or prompts that reliably create accessible React components following your team&rsquo;s conventions. These proven prompts deliver predictable, high-quality results, just like the code libraries we&rsquo;ve always relied on. We&rsquo;re moving from sharing snippets on GitHub Gists to building entire ecosystems for testing, sharing, and versioning our most effective prompts.</p>
<p>This shift isn&rsquo;t just about storing prompts - it&rsquo;s about the emergence of prompt engineering as a crucial skill. My recent research revealed that 56% of software engineers see prompt engineering as highly important for their future role, while only 21% consider it unimportant.</p>
<figure class="center"><img src="http://annievella.com/images/importance_of_prompt_engineering.png"
    alt="Graph showing that over half of surveyed software engineers consider prompt engineering to be extremely or very important for their future role"><figcaption>
      <p>Future of Prompt Engineering</br>Over half of surveyed software engineers consider prompt engineering to be extremely or very important for their future role</p>
    </figcaption>
</figure>

<h3 id="2-intent-records-and-templates">2. Intent Records and Templates</h3>
<p>Here&rsquo;s another idea worth exploring: as AI increasingly generates our code, we need better ways to capture the reasoning behind implementation choices. I&rsquo;m imagining something that I&rsquo;m calling  <strong>Intent Records</strong> - think of them like Architecture Decision Records (ADRs) but specifically designed for AI generation, capturing both what to build and why to build it that way.</p>
<p>An Intent Record could specify something like: &ldquo;We need a caching layer that prioritises read speed over write speed because our analytics dashboard needs to handle 10,000 concurrent users viewing real-time data&rdquo;. To standardise these records, we could develop <strong>Intent Templates</strong> - similar to how Detailed Design Documents (DDDs) structure their content - ensuring teams capture all necessary requirements, constraints, assumptions and design decisions that guide AI code generation.</p>
<h3 id="3-spec-modules">3. Spec Modules</h3>
<p>Building on this concept of structured documentation, here&rsquo;s another idea to consider: what if we had reusable building blocks for creating AI-ready specifications? We could call them <strong>Spec Modules</strong> - pre-built specification components that describe in detail specific types of functionality. Need authentication? You&rsquo;d grab a spec module that defines the security requirements, API endpoints, and user flows. Want a shopping cart? There&rsquo;d be a module ready to customise with your specific business rules.</p>
<p>By breaking down specifications into these AI-friendly modules, you wouldn&rsquo;t just be making your work more efficient - you&rsquo;d be creating a new kind of component library. One that exists at a higher level than traditional code libraries, providing AI systems with clear, consistent instructions for generating reliable, production-ready code.</p>
<h2 id="rethinking-the-sdlc-ai-is-pushing-back">Rethinking the SDLC: AI is Pushing Back</h2>
<p>For as long as software engineering has existed, we&rsquo;ve been searching for ways to build better software with less pain. Faster builds, simpler deployments, shorter feedback loops. Every new methodology, every new tool, every process improvement - it&rsquo;s all been about reducing friction and cognitive load in the development pipeline.</p>
<p>And now, AI coding assistants have done something remarkable. They‚Äôve removed one of our longest-standing bottlenecks: the speed of writing code. It‚Äôs no longer a question of how fast we can build something - it‚Äôs a question of whether we can keep up with what we‚Äôre creating.</p>
<p>But software development isn‚Äôt just about writing code. It never was. The real work happens before the first line is written and long after the last commit. And now that we‚Äôve uncapped code generation speed, we‚Äôre seeing pressure shift to everything around it - design, testing, review, deployment. The SDLC is pushing back.</p>
<p>In <a href="https://dl.acm.org/doi/10.1145/3715003">The Future of AI-Driven Software Engineering (Terragni et al., 2025)</a>, we explored where this shift is leading us. AI isn&rsquo;t just accelerating development - it&rsquo;s reshaping the way we build software altogether. Requirements need to be clearer. Design decisions and intent need to be explicit and recorded. Testing and validation need to scale. Our workflows, our tools, even our mental models of software engineering are being rewritten in real time. Our research suggests that AI itself might help address these emerging needs - from requirements analysis through to testing and deployment - though with varying levels of maturity across different stages of the lifecycle.</p>
<p>The implications are profound. <strong>The teams that understand and adapt to these system pressures now will be the ones that thrive in the AI era</strong>. As AI reshapes software development, it&rsquo;s not just changing our tools - it&rsquo;s transforming how we think about the entire discipline. The engineers who thrive in this new era will be those who excel at shaping intent, thinking in systems, and designing solutions that leverage both human insight and AI capabilities to build better software in ways we&rsquo;re only beginning to imagine.</p>
]]><![CDATA[<hr><p>Thanks for reading this post via RSS! üëã</p>]]><![CDATA[<a href="mailto:annie.luxton@gmail.com?subject=The SDLC Strikes Back: Adapting to AI-Driven Development">Reply to this post by email</a>]]></description>
    </item>
    <item>
      <title>What It&#39;s Really Like Using an AI Coding Assistant</title>
      <link>http://annievella.com/posts/what-its-really-like-using-an-ai-coding-assistant/</link>
      <pubDate>Sat, 25 Jan 2025 00:00:00 +1300</pubDate><author>annie.luxton@gmail.com (Annie Vella)</author>
      <guid>http://annievella.com/posts/what-its-really-like-using-an-ai-coding-assistant/</guid>
      <description>
      
      
      <![CDATA[<p>I&rsquo;ve now spent a couple of months using <a href="https://codeium.com/windsurf">Windsurf</a> fairly regularly and I thought I&rsquo;d share some of my experiences with it.</p>
<p>To set the scene, I&rsquo;m a software engineer with over 20 years experience. I have a degree in Computer Science and Math and spent the first half of my career in hands-on individual contributor roles across 7 industries and 4 countries. I would generally describe myself as a C# .NET backend dev but I&rsquo;ve built my fair share of frontends and even some mobile apps. I&rsquo;ve hopped back and forth between management and engineering roles over the last decade. I haven&rsquo;t written code as part of my day job for about 5 years now. I still enjoy building software myself and have plenty of grand ideas that I&rsquo;d love to bring to life, but sadly it just takes too long.</p>
<p>I&rsquo;ve been using Windsurf to help me write R and Python scripts for my research. Besides that, I&rsquo;ve been tinkering with agentic AI frameworks like <a href="https://crew.ai/">CrewAI</a> (more Python), a couple of small web-based games (JavaScript) and experimented building mobile apps (React Native). These experiences have taught me a lot about working with AI coding assistants.</p>
<p>Before I dive into my specific experiences, it&rsquo;s worth noting that as with any new technology, it takes time to learn how to use it well. There&rsquo;s simply nothing as effective as real hands-on experience and deliberate practice to build skills. Learning how to collaborate with an AI coding assistant is no different. In fact, initial insights from my Master&rsquo;s research shows that there is a strong correlation between frequency of use and developer productivity, with daily users reporting significantly higher productivity than infrequent users.</p>
<figure class="center"><img src="http://annievella.com/images/productivity_by_frequency.png"
    alt="Graph showing the relationship between AI coding assistant usage frequency and developer productivity. Daily users report significantly higher productivity gains compared to occasional users."><figcaption>
      <p>Productivity by Frequency of Use</br>Daily users report significantly higher productivity gains compared to occasional users.</p>
    </figcaption>
</figure>

<p>With that in mind, let me share what I&rsquo;ve discovered about these tools - both the parts that have delighted me and the parts that have occasionally frustrated me. My experience aligns well with what other developers have reported: there&rsquo;s a lot to love, but also some important quirks to be aware of.</p>
<h3 id="the-good-parts">The Good Parts</h3>
<h4 id="its-like-a-fabulously-helpful-pair-programmer">It&rsquo;s like a fabulously helpful pair programmer</h4>
<p>Using Windsurf really does feel like you have an endlessly patient and supportive pair programmer by your side. Interactions feel natural, like you&rsquo;re actually collaborating on a piece of work with another human being. It helps you think through problems, suggests improvements, and catch potential issues before they become bugs.</p>
<h4 id="its-great-at-automating-away-toil-and-repetitive-tasks">It&rsquo;s great at automating away toil and repetitive tasks</h4>
<p>Have you ever had to go through and tediously update heaps of files or strings just for consistency&rsquo;s sake? Sometimes you can get away with a simple find + replace, but sometimes that just doesn&rsquo;t cut it. Windsurf can pick up on these sorts of patterns and rip through them automatically, systematically updating every occurrence in a file or string. This can save you a lot of time!</p>
<p>I should mention that sometimes it doesn&rsquo;t pick up on all the instances, so it&rsquo;s a good idea to double check its work - but it certainly takes most of the grunt work away from you.</p>
<h4 id="it-can-run-scripts-see-the-results-and-react-autonomously">It can run scripts, see the results and react autonomously</h4>
<p>When using Windsurf&rsquo;s Cascade feature in &lsquo;Write&rsquo; mode, it will not only create and edit source code, but it will also offer to run it for you. You can configure it to run certain commands automatically, but otherwise it will just pause and ask for your confirmation. If you let it run your script, it will see any output or logs that would&rsquo;ve been piped out to the terminal. If there are any errors in that output, it will automatically attempt to fix them. If not, it may try to summarise what it saw and provide insights or suggestions.</p>
<p>You see what I mean when I say it&rsquo;s like having a fantastic pair programmer by your side?</p>
<h4 id="its-great-for-prototyping-and-experimenting-with-unfamiliar-languages">It&rsquo;s great for prototyping and experimenting with unfamiliar languages</h4>
<p>As I mentioned earlier, I&rsquo;ve been using Windsurf to help me write R and Python scripts - languages that I&rsquo;ve barely ever used before. In the past, I didn&rsquo;t steer clear of trying new technologies, but it would just take me a long time to get anything done. Windsurf has made it so much easier to prototype and experiment with code, supporting you in a way that reduces cognitive load and gives you a sense of confidence.</p>
<p>However, this ease of use comes with an important caveat: you still need a solid foundation in programming concepts. These tools are incredibly powerful, but they&rsquo;re more like highly capable assistants that help you implement your ideas, rather than complete replacements for programming knowledge. They can help you learn a new language&rsquo;s syntax or framework&rsquo;s API, but they can&rsquo;t teach you fundamental programming principles from scratch.</p>
<p>This leads to an interesting challenge: while these tools make it easier to try new things, it&rsquo;s hard to gauge how much you&rsquo;re actually learning. I can write R and Python code much faster now, but I&rsquo;m not sure I could write particularly good code in either language without continued AI assistance. It&rsquo;s a bit like having training wheels that you&rsquo;re not sure you should take off.</p>
<p>This is exactly what Addy Osmani describes in his article about the &ldquo;<a href="https://addyo.substack.com/p/the-70-problem-hard-truths-about">70% problem</a>&rdquo;. The initial progress feels almost like magic - you&rsquo;re writing code in languages you barely know! But then reality kicks in: without underlying experience and expertise, you may find yourself stuck at that 70% mark, unable to tackle the more complex challenges that require deeper understanding.</p>
<h3 id="the-annoying-parts">The Annoying Parts</h3>
<h4 id="it-can-get-stuck-in-an-endless-loop-of-incorrect-suggestions">It can get stuck in an endless loop of incorrect suggestions</h4>
<p>Sometimes you&rsquo;ll ask it to write some code and it won&rsquo;t get it right. Then you&rsquo;ll tell it that that didn&rsquo;t work and it will try something else, which also doesn&rsquo;t work. This back and forth can go on for a while, and often it can lead you right back to the original incorrect suggestion. As you can imagine, this can get quite frustrating!</p>
<p>Since Windsurf has this agentic nature, it can also end up in this sort of loop itself - recognising that it&rsquo;s made a mistake and trying to fix it repeatedly. The biggest downside of this is that it can end up making a lot of unnecessary changes to your code which you then need to try and unpick.</p>
<p>My advice here is to recognise when it&rsquo;s going down these sorts of rabbit holes and asking it to stop, undo all the changes it&rsquo;s made, go back to the start of the task, take the time to think about the problem, use chain-of-thought reasoning, make plan and start again. It can also help to tell it to make the least amount of change possible. This is often enough to help it find a better solution quicker.</p>
<h4 id="its-not-great-with-transitive-relationships-in-scripts">It&rsquo;s not great with transitive relationships in scripts</h4>
<p>I&rsquo;m not sure if it&rsquo;s the way I&rsquo;m structuring my R scripts or a limitation of the tool, but say I&rsquo;ve got an R script (analysis.R) which loads another (setup.R), which in turn loads another (helper.R). I expect Windsurf to know that it can access and should use functions defined in helper.R from analysis.R, but it often doesn&rsquo;t and instead creates new functions directly in analysis.R. I have to keep reminding it to reuse the functions defined in helper.R.</p>
<h3 id="the-surprising-parts">The Surprising Parts</h3>
<h4 id="it-makes-mistakes-but-knows-it-too">It makes mistakes, but knows it too</h4>
<p>Like humans, it makes mistakes. However, every now and then you see evidence of the underlying agentic nature of Windsurf kicking in. It will make some changes, realise that it&rsquo;s made a mistake, and fix it all by itself. This is probably one of the most impressive things I&rsquo;ve seen it do.</p>
<h4 id="it-doesnt-question-you-and-takes-most-of-your-suggestions-seriously-even-when-it-was-right">It doesn&rsquo;t question you and takes (most of) your suggestions seriously, even when it was right</h4>
<p>I&rsquo;ve noticed that it will generally trust you even when you&rsquo;re wrong. For example, if it suggests some code and you ask whether that is the most efficient way to do it, even if you know that it is, it will second-guess itself and suggest a different, less efficient approach instead.</p>
<p>What I tend to do is when I ask it a question like <em>&ldquo;is this really the best way to do this?&rdquo;</em> is add <em>&ldquo;challenge me if you disagree&rdquo;</em>. This seems to help it assess my question more freely, rather than just agreeing with me and finding another potentially less ideal because I dared ask.</p>
<h4 id="the-model-youre-using-really-matters">The model you&rsquo;re using really matters</h4>
<p>Windsurf allows you to choose between three models: GPT 4o, Claude 3.5 Sonnet and Cascade Base. I&rsquo;ve tried GPT 4o and Claude 3.5 Sonnet primarily, and I&rsquo;ve got to say that Claude 3.5 Sonnet beats GPT 4o for the sort of coding tasks I&rsquo;ve been using it for, hands down. Interestingly, I&rsquo;m a huge fan of GPT 4o via ChatGPT for everyday tasks, but for coding, Claude 3.5 Sonnet is my go-to choice now.</p>
<h4 id="if-you-want-structured-outputs-give-it-structured-prompts">If you want structured outputs, give it structured prompts</h4>
<p>Think of using these tools like talking to another developer, perhaps someone early on in their career. If you give them vague requirements, chances are that what they&rsquo;ll build won&rsquo;t be quite what you were after. If you give them clear and concise specifications, there&rsquo;s a better chance of getting what you want.</p>
<p>The same thing applies when using AI coding assistants. The more specific you can be, the more likely the outcome will match your expectations.</p>
<h4 id="keep-changesets-small-and-commit-often---source-control-is-your-friend">Keep changesets small and commit often - source control is your friend</h4>
<p>Keeping changes small and focused is a fundamental best practice in software development, regardless of your tools. However, it becomes even more critical when using AI coding assistants because they can generate code so quickly that you&rsquo;ll have hundreds of changes before you realize it. The larger the changeset, the harder it is to spot mistakes and the more time-consuming the review process becomes.</p>
<p>I&rsquo;m not alone in noticing this challenge. The <a href="https://dora.dev/research/2024/dora-report/">2024 DORA Report</a> found that AI adoption is actually negatively impacting software delivery performance, contrary to what many expected. Their research suggests that the dramatic increase in productivity and code generation speed is leading to larger changesets, contradicting DORA&rsquo;s principle of small batch sizes which are essential for stability.</p>
<figure class="center"><img src="http://annievella.com/images/dora-negative-impact-on-delivery-throughput-and-stability.png"
    alt="Graph from the 2024 DORA Report showing how AI adoption is correlating with decreased software delivery throughput and stability metrics"><figcaption>
      <p><a href="https://dora.dev/research/2024/dora-report/">2024 DORA Report Finding</a></br>AI adoption appears to be negatively impacting software delivery throughput and stability</p>
    </figcaption>
</figure>

<h3 id="so-what-does-the-future-hold">So what does the future hold?</h3>
<p>Research clearly shows that AI coding assistants boost developer productivity, but their impact goes far beyond simple efficiency gains. These tools are enabling a renaissance in personal software development. By handling routine tasks and reducing the cognitive load of working with unfamiliar technologies, they free us up to focus on what truly matters - creating innovative software that delights users and makes us proud.</p>
<figure class="center"><img src="http://annievella.com/images/windsurf-public-profile-jan-2025.png"
    alt="Screenshot of my public Windsurf profile showing statistics about my coding activity and language usage over the past two months"><figcaption>
      <p><a href="https://codeium.com/profile/codefrenzy">My Windsurf Profile</a></br>Statistics from two months of AI-assisted development</p>
    </figcaption>
</figure>

<p>To be honest, it&rsquo;s been a while since I spent so much time coding. Not for a lack of ideas - I&rsquo;ve got plenty of those - but for lack of time. Building anything useful takes time, precious time. But with AI coding assistants, I feel <em>supercharged</em>. The barrier between having an idea and bringing it to life has never been lower, especially for experienced developers who can guide these tools effectively.</p>
<p>Yet this new era of software development brings its own unique challenges. How do we effectively provide AI assistants with enough context about our codebase? How should we store and version control the prompts or specifications we use to guide code generation? And what about the explosion in the number of repositories being created, now that the barrier to creating new projects is so much lower? These represent entirely new problems that we&rsquo;ll need to solve as this technology matures, and I&rsquo;ll be writing more about each of these areas as I uncover and learn more about them.</p>
<p>If you haven&rsquo;t tried an AI coding assistant yet, I strongly encourage you to give it a go. Pick a tool that suits you best and get started. Start small, be patient as you learn how to work with them effectively, and most importantly - have fun exploring what&rsquo;s possible. Remember that these tools are currently the worst they&rsquo;ll ever be - just two years ago, what we now take for granted seemed almost impossible.</p>
<p>The future of software development is being reshaped right now, and it&rsquo;s an incredibly exciting time to be part of it.</p>
]]><![CDATA[<hr><p>Thanks for reading this post via RSS! üëã</p>]]><![CDATA[<a href="mailto:annie.luxton@gmail.com?subject=What It's Really Like Using an AI Coding Assistant">Reply to this post by email</a>]]></description>
    </item>
    <item>
      <title>Agents All The Way Down</title>
      <link>http://annievella.com/posts/agents-all-the-way-down/</link>
      <pubDate>Mon, 13 Jan 2025 00:00:00 +1300</pubDate><author>annie.luxton@gmail.com (Annie Vella)</author>
      <guid>http://annievella.com/posts/agents-all-the-way-down/</guid>
      <description>
      
      
      <![CDATA[<p>The concept of <strong>agentic AI</strong> absolutely fascinates me. An LLM on its own is already mind-blowing, but building much larger systems where hundreds of specialised LLMs work together as components, with yet another LLM orchestrating how it all works, is a whole other world. The possibilities for automation are endless.</p>
<p>At the end of the day, software systems are just components stitched together to perform seemingly complex tasks, but the logic behind it all is very <em>deterministic</em>. As software engineers, we write lines of code to tell computers to do very specific things, in very specific orders. The computer then executes those instructions in a deterministic way, and we&rsquo;re left with a very predictable system that can be hard to change or adapt to new requirements.</p>
<p>With agentic AI, we&rsquo;re no longer bound by the limitations of this deterministic approach. Agentic AI allows us to use LLMs to intelligently adapt and evolve these integrations. We simply equip agents with skills (tools) and memory to help them solve problems, and they work out the rest on their own. These agents can use various architectures to tackle problems - one popular approach is <a href="https://medium.com/@gauritr01/part-1-react-ai-agents-a-guide-to-smarter-ai-through-reasoning-and-action-d5841db39530">ReACT</a> (Reasoning + Acting, not the frontend framework we all know and love), which allows them to think through problems step by step, just like a human would - reasoning about what to do next, then taking action based on that reasoning.</p>
<figure class="center"><img src="http://annievella.com/images/ai-agent-overview.png"
    alt="Diagram showing the components of an agentic AI system including tools, memory, planning, and reflection capabilities"><figcaption>
      <p>The architecture of an agentic AI system showing how agents can use tools, maintain memory, and engage in complex reasoning. <br/> Credit: <a href="https://commons.wikimedia.org/wiki/File:AI_Agent_Overview.png">Lillian Weng</a>, <a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a>, via Wikimedia Commons</p>
    </figcaption>
</figure>

<h2 id="the-rise-of-agentic-ai">The Rise of Agentic AI</h2>
<p>I&rsquo;m certainly not alone in my enthusiasm for agentic AI.</p>
<p>Just in the last week, Jensen Huang, CEO of NVIDIA, remarked that we&rsquo;re entering the era of agentic AI at the <a href="https://www.youtube.com/live/k82RwXqZHY8">CES 2025 event</a> and Sam Altman, CEO and co-founder of OpenAI, also said that &ldquo;AI agents will join the workforce&rdquo; in 2025 in his blog post, <a href="https://blog.samaltman.com/reflections">Reflections</a>:</p>
<blockquote>
<p>&ldquo;We believe that, in 2025, we may see the first AI agents ‚Äújoin the workforce‚Äù and materially change the output of companies.&rdquo;</p>
</blockquote>
<p>Microsoft <a href="https://techcommunity.microsoft.com/blog/microsoft365copilotblog/introducing-new-agents-in-microsoft-365/4296918">announced a set of new agents</a> for Microsoft 365 in November 2024, including:</p>
<ul>
<li>A Facilitator agent for Microsoft Teams, that will take notes and summarise meetings</li>
<li>An Interpreter agent for Microsoft Teams, allowing users to speak to one another in their language of choice</li>
<li>A Project Manager agent, which automates overseeing entire projects, including plan creation, task assignment, progress tracking and status reporting</li>
<li>An Employee Self-Service agent, enabling employees to get real-time answers and take action on key HR and IT topics</li>
</ul>
<p>The research community has also recognised the potential of agentic AI, with researchers from Berkeley, Stanford, Google DeepMind, OpenAI, Anthropic, MetaAI and others running fantastic massive open online courses like <a href="https://llmagents-learning.org/f24">Large Language Model Agents</a>:</p>
<blockquote>
<p>&ldquo;With the continuous advancement of LLM techniques, LLM agents are set to be the upcoming breakthrough in AI, and they are going to transform the future of our daily life with the support of intelligent task automation and personalization.&rdquo;</p>
</blockquote>
<p>I thoroughly recommend watching the lectures which are available on their <a href="https://www.youtube.com/playlist?list=PLS01nW3RtgopsNLeM936V4TNSsvvVglLc">YouTube Channel</a>.</p>
<p>It&rsquo;s impossible not to see the enormous potential in all this. The future of software lies in systems where LLMs drive the logic engine, dispatching instructions to invoke tools, which in turn can also be powered by LLMs. Erik Meijer captures this vision perfectly in his paper <a href="https://dl.acm.org/doi/pdf/10.1145/3676287">Virtual Machinations: Using Large Language Models as Neural Computers</a>, drawing parallels between conventional and neural computers:</p>
<figure class="center"><img src="http://annievella.com/images/erik-meijer-neural-computer-comparison.png"
    alt="Comparison of Conventional and Neural Computers - [Virtual Machinations: Using Large Language Models as Neural Computers](https://dl.acm.org/doi/pdf/10.1145/3676287)"><figcaption>
      <p>Comparison of Conventional and Neural Computers - <a href="https://dl.acm.org/doi/pdf/10.1145/3676287">Virtual Machinations: Using Large Language Models as Neural Computers</a></p>
    </figcaption>
</figure>

<p>Through his comparison of conventional and neural computers, Erik builds towards his fascinating work on developing a natural language-based reasoning language for programming these neural systems. This work has the potential to introduce a whole new type of computing and I can&rsquo;t wait to see what they achieve.</p>
<h2 id="from-theory-to-practice">From Theory to Practice</h2>
<p>With a bit of time on our hands this Christmas, <a href="https://jasonvella.com">Jason Vella</a> and I decided to run our own mini-hackathon. We set ourselves a goal of building something using an agentic AI, mainly for learning purposes. Even though the concept is quite nascent, there are already quite a number of agentic AI frameworks out there:</p>
<ul>
<li><a href="https://www.langchain.com/">LangChain</a>: A framework for developing applications powered by language models, with composability and modularity.</li>
<li><a href="https://python.langchain.com/docs/langgraph">LangGraph</a>: An extension of LangChain for creating stateful, multi-agent applications using a graph-based approach.</li>
<li><a href="https://microsoft.github.io/autogen/">AutoGen</a>: An open-source framework for building AI agents that can collaborate to solve complex tasks.</li>
<li><a href="https://www.crewai.com/">CrewAI</a>: A framework designed for rapid prototyping of multi-agent systems for ease of use and quick iteration.</li>
<li><a href="https://www.llamaindex.ai/">LlamaIndex</a>: A data framework for building LLM applications, focusing on data ingestion and retrieval.</li>
<li><a href="https://learn.microsoft.com/en-us/semantic-kernel/overview/">Semantic Kernel</a>: Microsoft&rsquo;s AI orchestration framework combining natural language processing with traditional programming.</li>
</ul>
<p>We chose to use <a href="https://www.crewai.com">CrewAI</a> as it seems to a good option for getting something up and running fairly quickly. They&rsquo;ve got some good <a href="https://github.com/crewAIInc/crewAI-examples?tab=readme-ov-file">examples</a> and loads of great <a href="https://docs.crewai.com/introduction">documentation</a>.</p>
<h2 id="going-meta-the-recursive-developer">Going Meta: The Recursive Developer</h2>
<p>CrewAI is a Python-based framework (it seems most are), and unfortunately I&rsquo;ve had very little experience writing Python. Luckily, I have become pretty good at using <a href="https://codeium.com/windsurf">Windsurf</a>. Its Cascade feature, powered by <a href="https://codeium.com/flows">AI Flows</a>, actively reasons about my intent and helps me write code in languages I&rsquo;m not familiar with - it&rsquo;s like having an AI collaborator that truly understands what I&rsquo;m trying to achieve. Although it&rsquo;s not entirely obvious, you can see when different agents within the flows are collaborating on a code change - sometimes it will make a change, recognise that it&rsquo;s made a mistake, and fix it - all without me having to say anything. So here I am, <em>using one agentic AI system to help me build another</em>, how delightfully meta and yet more proof that agentic AI is the future!</p>
<p>This experience validates what <a href="https://www.linkedin.com/in/andrewyng/">Andrew Ng</a> recently discussed in <a href="https://www.deeplearning.ai/the-batch/new-opportunities-for-the-new-year/">The Batch</a> about AI-coding assistants being especially effective for prototyping. It also aligns perfectly with findings from my Master of Engineering research on the impact of AI coding assistants on software engineering. In analysing software engineers&rsquo; responses about workflow changes, I have found that those using AI coding assistants were not only more likely to explore unfamiliar technologies but also felt they could prototype faster. To me, it feels like having an endlessly patient pair programmer to work with!</p>
<figure class="center full-width"><img src="http://annievella.com/images/initial-thematic-analysis-results.jpeg"
    alt="Initial thematic analysis of an open-ended question around software engineers&#39; perceived impact on their workflows" width="100%"><figcaption>
      <p>Initial thematic analysis of an open-ended question around software engineers&rsquo; perceived impact on their workflows</p>
    </figcaption>
</figure>

<h2 id="building-my-first-agentic-ai-system">Building My First Agentic AI System</h2>
<p>Out of the box, setting up a CrewAI project creates a simple, default &ldquo;Research Assistant&rdquo; crew which was nearly exactly what we chose as the first example anyway! Since I need to find and read papers for my Master&rsquo;s study, an automated research assistant felt like a practical, achievable and useful system to build.</p>
<p>At this point, Jason spun off to play with AutoGen while I designed my research assistant crew to find the five most relevant recent papers on a given topic, matching them against specific research questions, and then deliver a summary by email. I decided to give my &ldquo;research aggregator&rdquo; agent a custom tool using Google Scholar (via <a href="https://serpapi.com">SerpAPI</a>) and my &ldquo;research analyst&rdquo; agent another custom tool to send emails using the <a href="https://developers.google.com/gmail/api/quickstart/python">Gmail API</a>.</p>
<p>To run it automatically, I used <code>launchd</code>, although I&rsquo;m sure cron would&rsquo;ve done the job nicely too. And for the last couple of weeks, I&rsquo;ve received a daily digest of interesting and relevant papers on the impact of AI coding assistants on software engineering, complete with links and insights! I love it!</p>
<figure class="center"><img src="http://annievella.com/images/daily-research-digest-agentic-ai.png"
    alt="Daily Research Digest - delivered by my first agentic AI system built using CrewAI"><figcaption>
      <p>Daily Research Digest - delivered by my first agentic AI system built using CrewAI</p>
    </figcaption>
</figure>

<h2 id="the-challenges-of-non-deterministic-systems">The Challenges of Non-Deterministic Systems</h2>
<p>The biggest head-scratcher came when trying to pass variables between tasks. My research analyst agent has two jobs: summarise papers into a markdown file, then email that summary. Simple, right? My programmer brain figured I could configure the filepath once and pass it into each task as an argument - which you kind of can, but the agent seems to be modifying it before using it.</p>
<p>What I discovered is that working with agentic AI systems requires a different debugging mindset. When your system can think and adapt, tracking down why it&rsquo;s not behaving as expected becomes a lot more difficult. It&rsquo;s not just about finding logic errors anymore ‚Äì it&rsquo;s about understanding how the agent is interpreting and executing its tasks.</p>
<p>This and many other challenges will become the <strong>new software engineering problems</strong> to solve. I believe these are the sorts of problems that Computer Science and Software Engineering students will study in the future. This is something that I&rsquo;m particularly interested in and hope to continue to uncover further as I continue my research.</p>
<p>Besides that quirk, I spent most of my time building the logic for the tools. There&rsquo;s for sure going to be a market for these &rsquo;tools&rsquo; which are basically just little client libraries built over APIs. CrewAI allows you to use tools built for both <a href="https://docs.crewai.com/concepts/langchain-tools">LangChain</a> and <a href="https://docs.crewai.com/concepts/llamaindex-tools">LlamaIndex</a>, as long as you wrap them in custom tools.</p>
<h2 id="whats-next">What&rsquo;s Next</h2>
<p>When I was much younger, I used to stay up way too late building side projects. I seemed to have boundless energy to tinker away with the latest and greatest at the time (AJAX, Google Maps, then later, Windows Phone, Objective-C - ahh, the good ol&rsquo; days). But life got in the way and nowadays I never seem to find the time to spend building all the ideas I have. However, AI tools like Windsurf and ChatGPT have given me such a boost that many of these ideas now seem within reach again, removing the friction that often stops us from turning ideas into reality.</p>
<p>Then add the extended possibilities that agentic AI frameworks give us and well, it&rsquo;s not hard to see the massive opportunities that lie ahead. The only real constraint now is our imagination. If you can imagine it, you can probably build it - and fairly quickly, too.</p>
<p>Of course now that I&rsquo;ve built one of these, I want to build more. I&rsquo;ve always loved the idea of having software &ldquo;do things for me&rdquo; in the background and now, with little effort, it can do so much more. The hardest thing might be to train my brain to not limit itself when dreaming up the next side project.</p>
<p>If you&rsquo;re a software engineer reading this, please don&rsquo;t wait - dive in and start playing with these tools as soon as can. Like any new technology, they take time to master, but the learning curve is absolutely worth it. The sooner you start experimenting, the sooner you&rsquo;ll discover just how much they can amplify what you can build and how you build it. After all, it really is agents all the way down.</p>
]]><![CDATA[<hr><p>Thanks for reading this post via RSS! üëã</p>]]><![CDATA[<a href="mailto:annie.luxton@gmail.com?subject=Agents All The Way Down">Reply to this post by email</a>]]></description>
    </item>
    <item>
      <title>2024 In Review: Expanding Horizons</title>
      <link>http://annievella.com/posts/2024-in-review/</link>
      <pubDate>Thu, 02 Jan 2025 00:00:00 +1300</pubDate><author>annie.luxton@gmail.com (Annie Vella)</author>
      <guid>http://annievella.com/posts/2024-in-review/</guid>
      <description>
      
      
      <![CDATA[<p>2024 was a massive year for me, and even that feels like an understatement. I pushed myself to my limits in many ways, but have enjoyed every second of it. After all, if you&rsquo;re comfortable, you&rsquo;re not growing, right?</p>
<p>My passion for continuous learning kicked into overdrive these past couple of years, leading me down fascinating intellectual paths. Could it be that AI has helped make information more accessible? Or is it that I&rsquo;ve finally found my calling? I can&rsquo;t really say for sure, but I&rsquo;ve found myself deeply immersed in several interconnected domains:</p>
<ul>
<li><a href="https://annievella.com/deming/">W Edwards Deming</a>, <a href="https://annievella.com/posts/exploring-systems-thinking-through-russell-ackoff/">Russell Ackoff</a> and <a href="https://www.linkedin.com/posts/annievella_leadership-systemsthinking-activity-7264717823875137537-Joda">Peter Scholtes</a>
<ul>
<li>Systems Thinking</li>
<li>Leadership</li>
<li>Organisational Design</li>
</ul>
</li>
<li>Generative AI
<ul>
<li><a href="https://annievella.com/posts/an-early-exploration-of-ai-first-development/">AI-Assisted Development</a></li>
<li><a href="https://annievella.com/posts/is-agentic-ai-the-key-to-automating-human-work/">Agentic AI Systems</a></li>
<li>LLMs as CPUs</li>
</ul>
</li>
<li>Active Inference
<ul>
<li>Free Energy Principle</li>
<li>The Bayesian Brain</li>
<li>Information Theory</li>
<li>Cognitive Science</li>
</ul>
</li>
<li><a href="https://annievella.com/quantum-computing/">Quantum Computing</a>
<ul>
<li>Error Correction</li>
</ul>
</li>
</ul>
<p>These topics have rekindled a passion for abstract and theoretical thinking, something I enjoyed so much at university but could never find a practical reason to keep doing. Exploring these topics is leading to some fascinating new thoughts, tickling my brain in the best possible way. There&rsquo;s a constant desire to soak in more information and turn it into knowledge and honestly, it&rsquo;s becoming a bit of an obsession.</p>
<p>I&rsquo;m convinced that all this learning has been valuable in my role at Westpac NZ, where I continue to explore and shape what staff engineering and technical leadership mean at an organisational level. It&rsquo;s an energising mix of driving technical excellence and shaping strategy, while ensuring our engineering practices align with and support ourbusiness outcomes. What I love most is how it lets me champion both Systems Thinking and continuous learning - whether I&rsquo;m working with executives on strategic initiatives, collaborating with architecture teams on governance, or mentoring engineers to grow our technical leadership capability.</p>
<p>This obsession with learning has manifested in several ways this last year:</p>
<ul>
<li>I started a part-time, research-only Masters of Engineering at the University of Auckland. I designed and kicked off a longitudinal study to explore the impact of AI on software engineering. The first questionnaire is already collecting some really interesting data that I&rsquo;m enjoying analysing.</li>
<li>I continued to study Deming&rsquo;s philosophies and in the process, discovered other big thinkers like Russell Ackoff and Peter Scholtes. This has led to a deep sense of awakening around Systems Thinking and leadership. It has left me wondering why in all these years I had never come across these inspirational thinkers before, even though I&rsquo;ve read countless books on leadership. As a mentor said to me recently - <em>&ldquo;the student wasn&rsquo;t ready yet&rdquo;</em>.</li>
<li>I <a href="https://www.linkedin.com/posts/annievella_deming-leadership-systemsthinking-activity-7253124197604868096-AffF">attended a Deming Leadership Seminar</a> run by <a href="https://deming.org/">The Deming Institute</a> in Columbus, Ohio, connecting with many other Deming students and coaches, and deepening my understanding of his philosophies.</li>
<li>I even got to visit the IBM Innovation Lab in Poughkeepsie, New York, and <a href="https://www.linkedin.com/posts/annievella_quantumcomputing-ibmquantum-techdreamscometrue-activity-7251681532510117889-R1br">saw a real functioning quantum computer in person</a>!</li>
</ul>
<p>Beyond consuming data and information and transforming it into knowledge, I continued to push myself to share what I was learning through public speaking - something that still scares me but in a good way:</p>
<ul>
<li><a href="https://www.linkedin.com/posts/annievella_staffpluslondon-activity-7206572800386453504-5pN3">Taking the stage at StaffPlus London</a> marked a significant milestone - my first major international conference. While the prestigious nature of this event sparked many nerves, the experience proved incredibly rewarding.</li>
<li>I kept the momentum going by speaking at several other events and even <a href="https://annievella.com/files/ada-lovelace-day-auckland-october-2024-quantum-computing-101.pdf">gave a talk on Quantum Computing</a>.</li>
</ul>
<p>Perhaps the most unexpected development was rediscovering my love for coding. After years focused on leadership and management, analysing my research data in R and Python reignited that old spark. With the help of AI coding assistants, I&rsquo;m now enjoying getting things to work again. I even built an Agentic AI Research Assistant that curates and delivers personalised research paper digests daily for my Master&rsquo;s study - the kind of project that combines my love for coding with my passion for learning.</p>
<figure class="centre"><img src="http://annievella.com/images/github-contributions-2024.png"
    alt="My GitHub Contributions in 2024"><figcaption>
      <p>My GitHub Contributions in 2024</p>
    </figcaption>
</figure>

<p>Looking back, I&rsquo;m proud to have achieved my 2023 goal of speaking at an international conference, along with making significant strides in reading and writing more. While these achievements demanded considerable time and energy, the one area that didn&rsquo;t get enough attention was exercise - and I really miss that energy boost it gives me.</p>
<p>In 2025, my goal is to leverage all these learnings and become more efficient at capturing, processing, and digesting information. Hopefully this will create more space and time for exercise, because growth isn&rsquo;t just about the mind - it&rsquo;s about the whole system, right?</p>
<p><strong>Key Accomplishments of 2024:</strong></p>
<p><em>Conference Talks:</em></p>
<ul>
<li><a href="https://annievella.com/files/code-camp-wellington-april-2024-lessons-in-technical-leadership.pdf">Staff Engineering: A Technical Alternative to Management</a>¬†at¬†<a href="https://www.codecampwellington.nz/">Code Camp Wellington</a>¬†in Wellington, NZ, on April 13</li>
<li><a href="https://annievella.com/files/staffplus-london-june-2024-deming's-wisdom-for-staff-plus-engineers.pdf">Deming‚Äôs Wisdom for Staff+ Engineers: A Modern Take on Timeless Principles</a>¬†at¬†<a href="https://leaddev.com/events/staffplus-london-2024">StaffPlus London</a>¬†in London, UK, on June 11</li>
<li>The Biggest Lessons I‚Äôve Learned as an Engineering Leader at¬†<a href="https://lu.ma/cpr2xlfy">The Movac Engineering Jam</a>¬†in Auckland, NZ, on September 17</li>
<li><a href="https://annievella.com/files/ada-lovelace-day-auckland-october-2024-quantum-computing-101.pdf">Quantum Computing 101: An Easy Introduction to a Hard Topic</a>¬†at¬†<a href="https://events.humanitix.com/ada-lovelace-day-2024">Ada Lovelace Day</a>¬†in Auckland, NZ, on October 9</li>
</ul>
<p><em>Panels:</em></p>
<ul>
<li><a href="https://techwomen.nz/event/ada-lovelace-day-2024-celebrating-female-tech-leaders/">Ada Lovelace Day 2024 ‚Äì Celebrating Female Tech Leaders Panel</a>¬†in Auckland, NZ, on October 8</li>
<li>DevFest AI Panel in Auckland, NZ, on November 10</li>
</ul>
<p><em>Podcasts:</em></p>
<ul>
<li><a href="https://youtu.be/ZIQu5OKvN30?si=uF9JrNhFlD4X9ho9">S1E3 - Distinguished Engineer Annie Vella‚Äôs wild career journey and finding joy as a reluctant manager</a>¬†recorded with¬†<a href="https://www.linkedin.com/in/scott-carey-262b0225/">Scott Carey</a>¬†for¬†<a href="https://www.youtube.com/playlist?list=PLBzScQzZ83I-s27CEsc9c1hbTy9fbdmEH">LeadDev PriorityZero Podcast</a>¬†in London, UK, on June 11</li>
<li><a href="https://open.spotify.com/episode/45J4XmqB9pj60H79nThgqC?si=b5c069df8e9a4823">Systems Thinking, AI, and Innovation with Annie Vella</a>¬†recorded with¬†<a href="https://www.linkedin.com/in/jakubjurkiewicz/">Jakub Jurkiewicz</a>¬†for¬†<a href="https://open.spotify.com/show/1vfos26hvJkCuhDZwl5MRv?si=f1bb69a3b43c47bd">Tech Waka Podcast</a>¬†in Auckland, NZ, on November 26</li>
</ul>
<p><em>Conferences Attended:</em></p>
<ul>
<li><a href="https://techcommunity.microsoft.com/blog/mvpawardprogramblog/microsoft-ai-tour--sydney-bengaluru-tokyo/4093971">Microsoft AI Tour</a> in Sydney, Australia, on February 7</li>
<li><a href="https://deming.org/events/2024-deming-leadership-seminar/">Deming Leadership Seminar</a> in Columbus, Ohio, USA, on October 16 &amp; 17</li>
</ul>
<p><em>Books Read / In Progress:</em></p>
<ul>
<li>&ldquo;What Is ChatGPT Doing &hellip; And Why Does It Work?&rdquo; by Stephen Wolfram</li>
<li>&ldquo;The New Economics&rdquo; by W. Edwards Deming</li>
<li>&ldquo;The Leader&rsquo;s Handbook: Making Things Happen, Getting Things Done&rdquo; by Peter Scholtes</li>
<li>&ldquo;Active Inference: The Free Energy Principle in Mind, Brain, and Behavior&rdquo; by Thomas Parr, Giovanni Pezzulo, and Karl J. Friston</li>
</ul>
]]><![CDATA[<hr><p>Thanks for reading this post via RSS! üëã</p>]]><![CDATA[<a href="mailto:annie.luxton@gmail.com?subject=2024 In Review: Expanding Horizons">Reply to this post by email</a>]]></description>
    </item>
    <item>
      <title>Dear Software Engineer: It&#39;s Time to Reclaim Your Role</title>
      <link>http://annievella.com/posts/dear-software-engineer/</link>
      <pubDate>Thu, 26 Dec 2024 00:00:00 +1300</pubDate><author>annie.luxton@gmail.com (Annie Vella)</author>
      <guid>http://annievella.com/posts/dear-software-engineer/</guid>
      <description>
      
      
      <![CDATA[<p><em>Apologies, this is a long one - clearly I&rsquo;ve got a lot to say on this subject!</em></p>
<p>It didn&rsquo;t take long after ChatGPT was released for me to start seeing how fundamentally this technology could transform software engineering. Not just as another tool in our arsenal, but as something that could redefine what it means to be a software engineer entirely.</p>
<p>The discourse around this has been fascinating. Jump on LinkedIn or X and you&rsquo;ll see endless debates about whether AI will augment or replace software engineers, whether it&rsquo;s just another productivity tool or a paradigm shift, whether it&rsquo;s overhyped or understated. But I think many are missing the real story - it&rsquo;s not about whether AI will take our jobs, it&rsquo;s about how it&rsquo;s already changing the very nature of our profession.</p>
<figure class="center"><img src="http://annievella.com/images/software-engineering-is-dead.png"
    alt="Software Engineering is Dead"><figcaption>
      <p><a href="https://x.com/KevinNaughtonJr/status/1796241418484334722">Software Engineering is Dead</a></p>
    </figcaption>
</figure>

<p>This transformation has captured my attention deeply. You see, I&rsquo;m a software engineer. I still call myself one even though it&rsquo;s been a few years since I actively <em>built</em> software because I&rsquo;ve been busy leading teams of software engineers for the last few years. But I still think of myself as a software engineer.</p>
<p>You&rsquo;ll often hear me talk about how much I&rsquo;ve loved my career, because I genuinely have. Perhaps I was lucky and found my calling at a very young age, but ever since I lay my little 6-year-old fingers on that Commodore 64, I was hooked. Since I believe software engineering has been a great career choice, and I want everyone to experience the same joy and fulfillment that I have, I&rsquo;ve encouraged many people to consider it as a career over the years.</p>
<p>Until now, most changes I&rsquo;ve experienced in our field felt more like evolution than revolution. I saw web technologies take off - remember when AJAX became a thing and jQuery was your ticket to building cool dynamic websites? I lived through mobile taking off, cloud computing, CI/CD, and so on. But in many ways, we were just doing the same things with newer toys: new frameworks, new approaches, much more automation.</p>
<h3 id="when-ai-changes-everything">When AI Changes Everything</h3>
<p>What‚Äôs happening now with AI, however, feels far more like a <strong>tectonic shift</strong> than just another iteration of the same old cycle - and my Master&rsquo;s research is confirming this. The data clearly shows that AI is already having a significant impact on how software engineers work. Not everyone sees it. Not everyone <em>wants</em> to see it. But it&rsquo;s happening.</p>
<p>Many in our industry remain confident that our roles as software engineers are safe because software engineering is much more than coding. The prevailing argument is that while AI might help us write code faster, the &ldquo;real&rdquo; work of software engineering lies in designing systems, making architectural decisions, and understanding user needs. It&rsquo;s a comforting thought, isn&rsquo;t it? A neat way to put AI back in its box as just another productivity tool.</p>
<p>I totally agree that software engineering <em>should</em> be a lot more than just writing code. When I studied computer science at university, they taught us how to elicit requirements, write user stories, design user interfaces and apply UX principles, architect complex systems, create test plans, execute test cases and so much more. The whole shebang.</p>
<p>But here&rsquo;s where it gets interesting: many developers today aren&rsquo;t actually doing all those tasks anymore. I&rsquo;m lucky enough that for the first 10 years of my career, when I was an individual contributor, I got to do all these things. I spoke to clients and stakeholders directly, gathered requirements, asked questions, made suggestions, and challenged their assumptions. Ultimately, I was given problem statements and solved them. I wrote frontend and backend code, designed database schemas and built them all from scratch, wrote and fine-tuned SQL queries, configured web servers, set up build pipelines, and monitored how things were running. I felt unstoppable - through hands-on practice, I had gained the skills to build and run software end-to-end. And god, it felt good. At my core, I was solving problems, and that&rsquo;s what I love doing.</p>
<h3 id="how-we-got-here-the-rise-of-specialisation">How We Got Here: The Rise of Specialisation</h3>
<p>Looking back at that experience now, it feels like a different era. Over the last decade, I&rsquo;ve watched software engineers step back from many of these responsibilities. Many now focus almost entirely on writing the code, letting others handle everything else.</p>
<p>Why has this happened? Well, I&rsquo;m sure there are many reasons. I can&rsquo;t help but wonder if at least part of the reason is that as software needs grew exponentially, the demand for software engineers grew too - and there just weren&rsquo;t enough of us. So we found ways to divide and conquer through specialisation. We introduced roles like the Product Owner who speaks to the customer and collects requirements for us, so that we can focus on the part that others perceive to be the part that only developers can do - writing the code. In some organisations, there are also Business Analysts analysing requirements, Project Managers coordinating delivery, Designers doing the UI/UX, Architects doing the solution design, Quality Engineers doing the testing, and Platform Engineers setting up the infrastructure, running the pipelines, and generally keeping the lights on.</p>
<p>I&rsquo;m not alone in noticing this shift. <a href="https://www.linkedin.com/in/alexewerlof/">Alex Ewerl√∂f</a> wrote about this recently in his piece on <a href="https://blog.alexewerlof.com/p/breaking-role-to-titles">breaking roles into multiple titles</a>. He sees what I see - how splitting up our craft this way is making us lose the very things that made software engineering special: the ownership, the synergy, the true craftsmanship.</p>
<p>By breaking up what used to be the role of a software engineer into all these disparate jobs, what&rsquo;s really left? For a lot of software engineers, the only thing that&rsquo;s really left is writing the code.</p>
<h3 id="product-engineers-vs-traditional-engineers">Product Engineers vs. Traditional Engineers</h3>
<p>To prove my point, new titles like &ldquo;Product Engineers&rdquo; have emerged to describe software engineers who do what everyone claims software engineers should be doing - you know, all those things that supposedly keep us safe from AI.</p>
<p><a href="https://www.linkedin.com/in/sherifmansour/?originalSubdomain=au">Sherif Mansour</a> wrote a <a href="https://sherifmansour.medium.com/product-engineers-f424da766871">piece</a> describing product engineers as &ldquo;<em>not traditional engineers</em>&rdquo;. Another <a href="https://posthog.com/blog/what-is-a-product-engineer">article</a> distinguishes them as unique because they &ldquo;<em>care about building a solution to problems that provides value to users</em>&rdquo; - as opposed to just &ldquo;<em>writing code and shipping features</em>&rdquo; like traditional software engineers apparently do.</p>
<p>And here&rsquo;s the kicker. An <a href="https://www.vipshek.com/blog/product-engineer">article</a> from earlier this year describes product engineers as:</p>
<blockquote>
<p>In recent years, the software industry has started to adopt the term product engineer to refer to a customer-focused, full-stack engineer who blurs the lines between product and engineering roles. I think of product engineers as generalists who can take an ambiguous problem statement, define a solution to it in collaboration with users or customers, and design, implement, and deliver that solution.</p>
</blockquote>
<p>Hang on a second, I thought that was what <em>software engineers</em> did?!</p>
<p>Yikes. Talk about contradiction - our industry claims software engineering is about so much more than coding, yet we&rsquo;ve created a special new term for engineers who actually do those things, while regular software engineers have become specialised code writers and feature shippers. So much for all those things that were supposed to keep us safe from AI!</p>
<p>&ldquo;So what?&rdquo;, you might say. Perhaps there&rsquo;s room for both. After all, there&rsquo;s so much demand for software engineers, and maybe some just want to focus on writing the code.</p>
<h3 id="the-game-changer-generative-ai">The Game-Changer: Generative AI</h3>
<p>That argument might have held water a year ago. But then generative AI came along. Because as it turns out, LLMs (and agentic AI) are <strong>really good</strong> at writing code, and much, much faster than any human can. And here&rsquo;s the problem: most &ldquo;traditional&rdquo; software engineers today do little more than translate almost-pseudo-code written requirements in user stories into compilable code - exactly the kind of task that AI is becoming better at every single day.</p>
<p>Sure, if you&rsquo;re one of the rare &ldquo;product engineers&rdquo; who actually work on the full spectrum of software engineering, perhaps you&rsquo;re fine. But remember, we just established that this has become the exception rather than the rule.</p>
<h3 id="what-the-data-says">What the Data Says</h3>
<p>AI&rsquo;s impact on coding isn&rsquo;t just speculation. My Master&rsquo;s research so far has confirmed that AI coding assistants are already reducing the time professional software engineers spend on writing code, with a staggering 78% of 165 respondents across 28 countries feeling they&rsquo;re spending less time writing code.</p>
<figure class="center"><img src="http://annievella.com/images/impact-on-time-spent-on-software-engineering-tasks-with-AI-assistance.png"
    alt="Time Spent on Software Engineering Tasks with AI Assistance"><figcaption>
      <p>Time Spent on Software Engineering Tasks with AI Assistance</p>
    </figcaption>
</figure>

<p>I wrote about the potential impacts of AI on software engineering back in February 2024 - <a href="https://annievella.com/posts/an-early-exploration-of-ai-first-development/">An Early Exploration of AI-First Development</a> - and boy has this landscape changed since then. It feels like there are new tools that do more, better and faster being released every single day. My research survey ran for a month in October / November 2024, and I was stunned to see how many AI tools software engineers are already playing with. Windsurf didn&rsquo;t get a mention but it hadn&rsquo;t even been released yet!</p>
<figure class="center"><img src="http://annievella.com/images/most-used-AI-coding-assistants.png"
    alt="Most Used AI Coding Assistants"><figcaption>
      <p>Most Used AI Coding Assistants</p>
    </figcaption>
</figure>

<h3 id="steve-yegge-and-the-stubborn-developer">Steve Yegge and the Stubborn Developer</h3>
<p><a href="https://www.linkedin.com/in/steveyegge/">Steve Yegge</a> recently wrote a follow-up to his controversial article <a href="https://sourcegraph.com/blog/the-death-of-the-junior-developer">The Death of the Junior Developer</a>, reframing his position as <a href="https://steve-yegge.medium.com/the-death-of-the-stubborn-developer-b5e8f78d326b">The Death of the Stubborn Developer</a>. He talks about how if you‚Äôre not adopting Chat-Oriented Programming, or CHOP, you‚Äôre getting left behind.</p>
<blockquote>
<p>If you‚Äôre not using chop, then you‚Äôre plodding. You‚Äôre like one of those crusty old assembly-language holdouts still using asm in 1990 because compiler-generated code wasn‚Äôt fast enough. Stubborn bastards, the lot of ‚Äôem. Sound familiar?</p>
</blockquote>
<p>I agree with everything he says in his riveting but lengthy article, except perhaps the part about autonomous software agents. I‚Äôve spent the last month using Codeium‚Äôs <a href="https://codeium.com/windsurf">Windsurf</a> - self-described as the ‚Äúfirst agentic IDE‚Äù - and I tell you what, it‚Äôs absolutely incredible. This is so much more than just chat, copy, paste, repeat. With Windsurf, I tell it what I want and it generates <em>all</em> the code. All of it. And honestly, the code is good. And if it isn‚Äôt, I just tell it to fix it and it does! Sometimes it even recognises that it‚Äôs made a mistake before I do and it goes ahead and fixes it without me having to say anything. The future is here, my friends.</p>
<p><a href="https://www.cursor.com">Cursor</a> is another fantastic IDE that works in much the same way. And then there are countless other web-based tools that can create entire codebases from a prompt, like <a href="https://bolt.new">Bolt</a>, <a href="https://v0.dev">v0</a>, and of course, <a href="https://lovable.dev">Lovable.dev</a> which is gaining traction at an incredible rate.</p>
<h3 id="from-chop-to-baton">From CHOP to BATON</h3>
<p>These tools are just the beginning. I think we&rsquo;re rapidly moving into an era where humans no longer write code by hand. Instead, we instruct agentic AI systems that use LLMs to do it for us. But it&rsquo;s not just about one-on-one interaction with AI - the future might look more like managing an entire AI development team. In <a href="https://medium.com/@joe_30979/from-chop-to-baton-the-evolution-of-ai-assisted-development-cf80c9de2e3d">From CHOP to BATON: The Evolution of AI-Assisted Development</a>, the author explores what comes after CHOP, introducing a new paradigm called BATON - Bot-Assisted Task OrchestratioN:</p>
<blockquote>
<p>With BATON, your role shifts from being a hands-on coder to something more akin to a conductor or a project manager. You&rsquo;re no longer writing every line of code yourself, or even pair programming with an AI. Instead, you&rsquo;re breaking down projects into well-defined tasks, delegating them to multiple AI systems, and overseeing the entire development process. Need a suite of unit tests written? Delegate it. Have a simple, but annoying feature to implement? Assign it to your AI team.</p>
</blockquote>
<p>In other words, CHOP is just the beginning. With BATON, a software engineer&rsquo;s role shifts from coding line-by-line to orchestrating and overseeing multiple AI &ldquo;team members,&rdquo; each responsible for different chunks of work. This represents a fundamental change in what it means to be a software engineer - and a clear signal that we need to expand our skill sets beyond just writing code.</p>
<h3 id="so-what-can-you-do-about-it">So What Can You Do About It?</h3>
<p>If you‚Äôre a software engineer and upon reflection suspect you may have fallen into the trap of specialising as a code writer, listen up. It&rsquo;s time to broaden your horizons. To get started, you could try:</p>
<ul>
<li>Participating in all the activities involved in building software, not just writing code</li>
<li>Requesting problem statements instead of accepting pre-digested solutions disguised as user stories</li>
<li>Shifting yourself left - joining your Product Owner in stakeholder meetings, asking questions, challenging assumptions, and making suggestions</li>
<li>Understanding the drivers behind the work by exploring the data and decisions shaping your projects</li>
<li>Reading <a href="https://www.linkedin.com/in/gergelyorosz/">Gergely Orosz</a>&rsquo;s article on the <a href="https://blog.pragmaticengineer.com/the-product-minded-engineer/">9 key traits of product-minded engineers</a> and developing those skills</li>
</ul>
<p>So dear software engineer, please take heed. If you‚Äôre not a &ldquo;product engineer&rdquo; and have specialised in writing code, AI <em>may indeed take your job</em>. But this isn&rsquo;t just a warning - it&rsquo;s an opportunity. It&rsquo;s time to reclaim your role and return to what software engineering was always meant to be: a craft that combines technical expertise with problem-solving, user empathy, and business acumen. The future belongs to those with curiosity who can see beyond the code.</p>
]]><![CDATA[<hr><p>Thanks for reading this post via RSS! üëã</p>]]><![CDATA[<a href="mailto:annie.luxton@gmail.com?subject=Dear Software Engineer: It's Time to Reclaim Your Role">Reply to this post by email</a>]]></description>
    </item>
    <item>
      <title>The Power of Defining the Problem</title>
      <link>http://annievella.com/posts/the-power-of-defining-the-problem/</link>
      <pubDate>Sun, 29 Sep 2024 00:00:00 +1200</pubDate><author>annie.luxton@gmail.com (Annie Vella)</author>
      <guid>http://annievella.com/posts/the-power-of-defining-the-problem/</guid>
      <description>
      
      
      <![CDATA[<p>We live in an era where rapid solutions are celebrated. The quicker we solve a problem, the more productive we appear. But what if, in our rush to get to a resolution, we&rsquo;re missing the mark entirely? Albert Einstein&rsquo;s timeless quote, <em>&ldquo;If I were given one hour to save the planet, I would spend 59 minutes defining the problem and one minute resolving it&rdquo;</em>, resonates deeply in today‚Äôs fast-paced, technology-driven world.</p>
<blockquote class="large-quote" style="font-size: 1.5em; margin: 40px; margin-bottom: 0"> "If I were given one hour to save the planet, I would spend 59 minutes defining the problem and one minute resolving it."</blockquote>
<p style="margin: 40px; margin-top: 10px; font-size: 0.8em;"><em>‚Äî Albert Einstein</em></p>
<p>In my role, both as a software engineer and technical leader, I&rsquo;ve witnessed firsthand the tendency to dive into problem-solving without fully grasping the problem itself. We chase after solutions, applying our experience and tools without considering if we‚Äôre aiming at the right target. This often leads to wasted effort, frustration, and missed opportunities.</p>
<p>When we talk about defining the problem, it‚Äôs more than just identifying the obvious. It‚Äôs about understanding the underlying layers - the root cause, the impact on the business, the user, and the broader system. It requires patience, curiosity, and a willingness to challenge assumptions. In my experience, it‚Äôs this depth of understanding that separates good engineers from great ones.</p>
<h3 id="first-principles-the-foundation-of-solutions">First Principles: The Foundation of Solutions</h3>
<p>Once the problem is clearly defined, the next step is to solve it from first principles. This concept, which comes from physics, suggests that we break down complex problems into their most basic elements. By starting from these foundational truths, we avoid relying on assumptions or existing models that might not apply.</p>
<p>In the context of software engineering, solving from first principles forces us to rethink how we approach technical challenges. Are we building on outdated architectures or practices simply because &ldquo;that&rsquo;s how it&rsquo;s always been done&rdquo;? Are we making design choices based on constraints that no longer exist?</p>
<p>When I coach teams, I often find that revisiting first principles can be a powerful way to unlock innovation. It frees engineers from the burden of legacy thinking and opens up new pathways to more efficient, elegant solutions.</p>
<h3 id="but-what-about-the-gaps">But What About the Gaps?</h3>
<p>When we break things down to their most elemental parts, we gain clarity on each piece of the puzzle. But there&rsquo;s a danger here too - focusing only on the parts risks missing the important bits in between: the interactions.</p>
<p>It‚Äôs like trying to understand a car by focusing on each part separately. Sure, the engine, wheels, and brakes all have their functions, but it‚Äôs the way they all interact that makes the car drive smoothly. And this is where systems thinking comes in.</p>
<p>Systems thinking reminds us, as Russell Ackoff so aptly put it, that a system is more than the sum of its parts; it‚Äôs the product of their interactions. In a previous post, I explored Ackoff‚Äôs philosophy and the difference between <em>analysis</em> and <em>synthesis</em> - if you‚Äôre curious to explore that side of the conversation, feel free to check it out <a href="https://annievella.com/posts/exploring-systems-thinking-through-russell-ackoff/">here</a>.</p>
<blockquote class="large-quote" style="font-size: 1.5em; margin: 40px; margin-bottom: 0"> A system is never the sum of its parts; it‚Äôs the product of their interaction.</blockquote>
<p style="margin: 40px; margin-top: 10px; font-size: 0.8em;"><em>‚Äî Russell Ackoff</em></p>
<p>Whether we&rsquo;re debugging a piece of software or optimising a process, we need to look at how each part interacts with the others - and how the system as a whole interacts with the larger environment it&rsquo;s a part of. Only then can we fully understand what we&rsquo;re working with.</p>
<h3 id="so-whats-next">So, What‚Äôs Next?</h3>
<p>The journey to truly effective problem-solving is about discipline. Define the right problem to work on, then solve it from first principles - but don‚Äôt stop there. Remember to consider the interactions between the parts and the system‚Äôs place in the larger picture. It sounds simple, but it‚Äôs incredibly powerful when applied in practice.</p>
<p>In the world of software development, where speed and agility are prized, it‚Äôs tempting to jump to the solution. But if we pause - if we spend that crucial moment, as Einstein suggested, defining the problem thoroughly - we can ensure that our solutions are not only quick but also meaningful and lasting.</p>
<p>As technology continues to evolve, this approach will only become more crucial. The rise of AI, quantum computing, and other cutting-edge innovations will demand engineers who can not only execute quickly but also think deeply. That‚Äôs the kind of team I enjoy building and working with - one that thrives on curiosity, challenges assumptions, and delivers solutions that truly matter.</p>
]]><![CDATA[<hr><p>Thanks for reading this post via RSS! üëã</p>]]><![CDATA[<a href="mailto:annie.luxton@gmail.com?subject=The Power of Defining the Problem">Reply to this post by email</a>]]></description>
    </item>
    <item>
      <title>Quantum Computing</title>
      <link>http://annievella.com/quantum-computing/</link>
      <pubDate>Fri, 20 Sep 2024 00:00:00 +0000</pubDate><author>annie.luxton@gmail.com (Annie Vella)</author>
      <guid>http://annievella.com/quantum-computing/</guid>
      <description>
      
      
      <![CDATA[<p>Learning:</p>
<ul>
<li><a href="https://learning.quantum.ibm.com/">IBM Quantum Learning</a></li>
<li><a href="https://pennylane.ai/qml/">Learn quantum programming with PennyLane</a></li>
</ul>
<p>Programming:</p>
<ul>
<li><a href="https://www.ibm.com/quantum/qiskit">IBM Qiskit</a></li>
<li><a href="https://quantumai.google/cirq">Google Cirq</a></li>
<li><a href="https://learn.microsoft.com/en-us/azure/quantum/">Microsoft Q#</a></li>
</ul>
<p>YouTube:</p>
<ul>
<li><a href="https://youtu.be/F_Riqjdh2oM?si=XJWZtpvujF5qlWmD">Quantum Computing for Computer Scientists</a></li>
<li><a href="https://youtube.com/playlist?list=PLOFEBzvs-VvqKKMXX4vbi4EB1uaErFMSO&amp;si=uiMvezeeswCaSerF">Understanding Quantum Information &amp; Computation</a></li>
</ul>
]]><![CDATA[<hr><p>Thanks for reading this post via RSS! üëã</p>]]><![CDATA[<a href="mailto:annie.luxton@gmail.com?subject=Quantum Computing">Reply to this post by email</a>]]></description>
    </item>
    <item>
      <title>Resources</title>
      <link>http://annievella.com/resources/</link>
      <pubDate>Fri, 20 Sep 2024 00:00:00 +0000</pubDate><author>annie.luxton@gmail.com (Annie Vella)</author>
      <guid>http://annievella.com/resources/</guid>
      <description>
      
      
      <![CDATA[<p>This page contains links to curated collections of resources that I have found useful for learning about topics that I&rsquo;m passionate about. I&rsquo;ll keep adding to them so check back regularly for updates.</p>
<ul>
<li><a href="https://annievella.com/deming">W. Edwards Deming</a></li>
<li><a href="https://annievella.com/quantum-computing">Quantum Computing</a></li>
</ul>
]]><![CDATA[<hr><p>Thanks for reading this post via RSS! üëã</p>]]><![CDATA[<a href="mailto:annie.luxton@gmail.com?subject=Resources">Reply to this post by email</a>]]></description>
    </item>
    <item>
      <title>Speaking</title>
      <link>http://annievella.com/speaking/</link>
      <pubDate>Fri, 20 Sep 2024 00:00:00 +0000</pubDate><author>annie.luxton@gmail.com (Annie Vella)</author>
      <guid>http://annievella.com/speaking/</guid>
      <description>
      
      
      <![CDATA[<p>I&rsquo;ve always loved sharing my knowledge and experiences with others, but I didn&rsquo;t always have the courage to step onto a stage. In 2023, I decided to face my fear of public speaking head-on, embracing the mantra &ldquo;practice makes better&rdquo;. Since then, I&rsquo;ve jumped at every opportunity to talk about topics I&rsquo;m passionate about, and it&rsquo;s been an incredibly rewarding journey. Engaging with diverse minds at conferences and meetups has been especially fulfilling.</p>
<p>Below is a list of the talks, panels, and podcasts I&rsquo;ve participated in.</p>
<p>If you&rsquo;d like me to speak at your event, please feel free to <a href="mailto:annie.luxton@gmail.com">get in touch</a>. I&rsquo;d love to connect!</p>
<h2 id="2025">2025</h2>
<h3 id="talks">Talks</h3>
<ul>
<li>
<p>Joint talk with <a href="https://www.linkedin.com/in/jvella/">Jason Vella</a>: <a href="https://annievella.com/files/junior-dev-auckland-meet-august-2025-software-engineering-the-ai-reboot.pdf">Software Engineering: The AI Reboot</a> at <a href="https://www.meetup.com/juniordev-auckland/events/310074767/">JuniorDev Auckland Meet</a> in Auckland, New Zealand, on August 6</p>
</li>
<li>
<p>Opening keynote: <a href="https://annievella.com/files/yow-tech-leaders-summit-australia-june-2025-duality-of-ai-in-software-engineering.pdf">The Duality of AI in Software Engineering</a> at <a href="https://yowcon.com/tech-leaders-melbourne-2025/sessions/3662/the-duality-of-ai-in-software-engineering">YOW! Tech Leaders Summit</a> in Brisbane (June 17), Sydney (June 18), and Melbourne (June 19), Australia</p>
</li>
<li>
<p><a href="https://annievella.com/files/ai-native-devcon-webinar-may-2025-am-i-still-a-software-engineer-if-i-don't-write-the-code.pdf">Am I Still a Software Engineer If I Don&rsquo;t Write the Code?</a> - <a href="https://ainativedev.io/devcon/am-i-still-a-software-engineer-if-i-don't-write-the-code">Information</a> &amp; <a href="https://youtu.be/53yziql9h-U?si=2RJpT5Ve05fhHVdt">Recording</a> - at <a href="https://ainativedev.io/devcon">AI Native DevCon</a> remotely on May 13</p>
</li>
<li>
<p>Closing keynote: <a href="https://annievella.com/files/devops-summit-melbourne-march-2025-the-future-engineer.pdf">The Future Engineer: Redefining Software Engineering in the Age of AI</a> at <a href="https://forefrontevents.co/event/devops-summit-vic/">DevOps Summit Victoria</a> in Melbourne, Australia, on March 13</p>
</li>
</ul>
<h3 id="podcasts">Podcasts</h3>
<ul>
<li>
<p><a href="https://www.aviator.co/podcast/from-software-engineers-to-agent-managers">From Software Engineers to Agent Managers</a> recorded with <a href="https://www.linkedin.com/in/ankitjaindce/">Ankit Jain</a> for <a href="https://www.aviator.co/podcast">The Hangar DX Podcast from Aviator</a> remotely, on November 13</p>
</li>
<li>
<p><a href="https://techleadjournal.dev/episodes/223/">#223 - The Software Engineer Identity Crisis in the AI-Driven Future - Annie Vella</a> recorded with <a href="https://www.linkedin.com/in/henry-suryawirawan/">Henry Suryawirawan</a> for <a href="https://techleadjournal.dev">The Tech Lead Journal</a> remotely, on July 7</p>
</li>
<li>
<p><a href="https://ainativedev.io/podcast/annie-vella">From Builder to Orchestrator - Confronting the Software Engineer&rsquo;s Identity Crisis</a> recorded with <a href="https://www.linkedin.com/in/simonmaple/">Simon Maple</a> for <a href="https://ainativedev.io/podcast">AI Native Dev Podcast</a> remotely, on April 22</p>
</li>
</ul>
<h3 id="panels">Panels</h3>
<ul>
<li>
<p>Microsoft Executive Breakfast Panel on The Impact of AI on Work in Auckland, NZ, on November 24</p>
</li>
<li>
<p><a href="https://www.meetup.com/ba-career-meetup-group/events/310627929/">Auckland Panel Event: Tech Hiring, Behind-the-Scenes Insights</a> in Auckland, NZ, on September 11</p>
</li>
</ul>
<h3 id="roundtables">Roundtables</h3>
<ul>
<li>Co-hosting: <a href="https://annievella.com/files/lead-dev-march-2025-assessing-the-impact-of-ai-coding-assistants-roundtable.pdf">Assessing the Impact of AI Coding Assistants</a> with <a href="https://leaddev.com/community/scott-carey">Scott Carey</a> at <a href="https://www.leaddev.com">LeadDev</a> remotely, on March 5</li>
</ul>
<h2 id="2024">2024</h2>
<h3 id="talks-1">Talks</h3>
<ul>
<li>
<p><a href="https://annievella.com/files/code-camp-wellington-april-2024-lessons-in-technical-leadership.pdf">Staff Engineering: A Technical Alternative to Management</a> at <a href="https://www.codecampwellington.nz">Code Camp Wellington</a> in Wellington, NZ, on April 13</p>
</li>
<li>
<p><a href="https://annievella.com/files/staffplus-london-june-2024-deming's-wisdom-for-staff-plus-engineers.pdf">Deming&rsquo;s Wisdom for Staff+ Engineers: A Modern Take on Timeless Principles</a> - <a href="https://leaddev.com/culture/demings-wisdom-for-staff-engineers-a-modern-take-on-timeless-principles">Information</a> &amp; <a href="https://youtu.be/-QTI5U5TRbQ?si=xNP8Csk5TRp1qS9k">Recording</a> - at <a href="https://leaddev.com/events/staffplus-london-2024">StaffPlus London</a> in London, UK, on June 11</p>
</li>
<li>
<p>The Biggest Lessons I‚Äôve Learned as an Engineering Leader at <a href="https://lu.ma/cpr2xlfy">The Movac Engineering Jam</a> in Auckland, NZ, on September 17</p>
</li>
<li>
<p><a href="https://annievella.com/files/ada-lovelace-day-auckland-october-2024-quantum-computing-101.pdf">Quantum Computing 101: An Easy Introduction to a Hard Topic</a> at <a href="https://events.humanitix.com/ada-lovelace-day-2024">Ada Lovelace Day</a> in Auckland, NZ, on October 9</p>
</li>
</ul>
<h3 id="podcasts-1">Podcasts</h3>
<ul>
<li>
<p><a href="https://youtu.be/ZIQu5OKvN30?si=uF9JrNhFlD4X9ho9">S1E3 - Distinguished Engineer Annie Vella&rsquo;s wild career journey and finding joy as a reluctant manager</a> recorded with <a href="https://www.linkedin.com/in/scott-carey-262b0225/">Scott Carey</a> for <a href="https://www.youtube.com/playlist?list=PLBzScQzZ83I-s27CEsc9c1hbTy9fbdmEH">LeadDev PriorityZero Podcast</a> in London, UK, on June 11</p>
</li>
<li>
<p><a href="https://open.spotify.com/episode/45J4XmqB9pj60H79nThgqC?si=b5c069df8e9a4823">Systems Thinking, AI, and Innovation with Annie Vella</a> recorded with <a href="https://www.linkedin.com/in/jakubjurkiewicz/">Jakub Jurkiewicz</a> for <a href="https://open.spotify.com/show/1vfos26hvJkCuhDZwl5MRv?si=f1bb69a3b43c47bd">Tech Waka Podcast</a> in Auckland, NZ, on November 26</p>
</li>
</ul>
<h3 id="panels-1">Panels</h3>
<ul>
<li>
<p><a href="https://techwomen.nz/event/ada-lovelace-day-2024-celebrating-female-tech-leaders/">Ada Lovelace Day 2024 ‚Äì Celebrating Female Tech Leaders Panel</a> in Auckland, NZ, on October 8</p>
</li>
<li>
<p>DevFest AI Panel in Auckland, NZ, on November 10</p>
</li>
</ul>
<h2 id="2023">2023</h2>
<h3 id="talks-2">Talks</h3>
<ul>
<li>
<p><a href="https://annievella.com/files/code-camp-wellington-april-2023-staff-engineering.pdf">Staff Engineering: A Technical Alternative to Management</a> at <a href="https://www.codecampwellington.nz/2023/">Code Camp Wellington</a> in Wellington, NZ, on April 15</p>
</li>
<li>
<p><a href="https://annievella.com/files/devfest-auckland-november-2023-staff-engineering.pdf">Staff Engineering: A Technical Alternative to Management</a> at <a href="https://devfest-auckland.web.app">DevFest Auckland</a> in Auckland, NZ, on November 12</p>
</li>
</ul>
<h3 id="panels-2">Panels</h3>
<ul>
<li>
<p>Infosys International Women‚Äôs Day Panel in Auckland, NZ, on March 8</p>
</li>
<li>
<p>DevOps Summit Panel on Discussing the Capabilities of a World Class DevOps Strategy in Auckland, NZ, on June 14</p>
</li>
<li>
<p>Movac Panel on Building Diverse and High-Performance Engineering Cultures in Auckland, NZ, on June 21</p>
</li>
<li>
<p>Shadowtech Panel on a Day in the Life of an Engineer at Westpac, in Auckland, NZ, on September 14</p>
</li>
<li>
<p>DevFest Career Panel in Auckland, NZ, on November 12</p>
</li>
<li>
<p>TechWomen NZ and CyberCX Celebration Panel in Auckland, NZ, on December 5</p>
</li>
</ul>
<h2 id="2021">2021</h2>
<h3 id="podcasts-2">Podcasts</h3>
<ul>
<li>
<p><a href="https://youtu.be/fwYD9bqG9lE?si=7RaLQMgGv3wbFcAr">From Software Engineer to Engineering Manager with Annie Vella</a> recorded with <a href="https://www.linkedin.com/in/gergelyorosz/">Gergely Orosz</a> for <a href="https://www.pragmaticengineer.com">The Pragmatic Engineer</a> remotely, on January 21</p>
</li>
<li>
<p><a href="https://techleadjournal.dev/episodes/30/">#30 - The Engineering Career Dilemma &amp; Growing Through Self-Reflection - Annie Vella</a> recorded with <a href="https://www.linkedin.com/in/henry-suryawirawan/">Henry Suryawirawan</a> for <a href="https://techleadjournal.dev">The Tech Lead Journal</a> remotely, on February 11</p>
</li>
</ul>
]]><![CDATA[<hr><p>Thanks for reading this post via RSS! üëã</p>]]><![CDATA[<a href="mailto:annie.luxton@gmail.com?subject=Speaking">Reply to this post by email</a>]]></description>
    </item>
    <item>
      <title>Is Agentic AI the Key to Automating Human Work?</title>
      <link>http://annievella.com/posts/is-agentic-ai-the-key-to-automating-human-work/</link>
      <pubDate>Sat, 31 Aug 2024 09:00:00 +1200</pubDate><author>annie.luxton@gmail.com (Annie Vella)</author>
      <guid>http://annievella.com/posts/is-agentic-ai-the-key-to-automating-human-work/</guid>
      <description>
      
      
      <![CDATA[<p>I&rsquo;ve been contemplating the concept of <em>agentic AI</em> for a while now. The idea that we can create specialised AI agents, each mastering a specific task, and have them work together iteratively struck me as a powerful way to really harness the power of AI to tackle complex problems. After all, that&rsquo;s how teams of humans working together accomplish amazing outcomes, right?</p>
<p>I first encountered <em><a href="https://news.agpt.co">Auto-GPT</a></em> over a year ago and was intrigued enough to join their Discord community. At that time, the concept of autonomous AI agents was still in its early stages, and Auto-GPT was pioneering an approach that allowed AI systems to autonomously generate and execute their own goals. This innovative idea resonated with me, reinforcing my belief in the transformative potential of specialised AI agents across various industries.</p>
<p>As I continued to explore this concept, <a href="https://www.andrewng.org">Andrew Ng</a>&rsquo;s discussions on agentic AI further deepened my understanding, highlighting how these specialised agents could revolutionise the way we approach complex problems.</p>
<p>While the broad potential of agentic AI to automate and optimise a wide range of jobs is exciting, my focus naturally sharpens when I consider its application to software engineering. This focus ties back to my ongoing Master&rsquo;s research, where I‚Äôm exploring the broader impact of AI on software engineering practices. In this context, agentic AI stands out as particularly powerful, offering the possibility to fundamentally change how we develop, test, and maintain software.</p>
<h3 id="what-is-agentic-ai">What is Agentic AI?</h3>
<p>Agentic AI involves multiple specialised AI agents working collaboratively to achieve complex goals. Imagine a team of experts, each with a specific focus - one agent excels at writing code, another at testing, and yet another at conducting security reviews. These agents don&rsquo;t operate in silos; instead, they communicate, iterate, and refine their outputs together, much like a well-coordinated human team.</p>
<p>Andrew Ng, a prominent AI thought leader, emphasizes in his talks, <em><a href="https://youtu.be/sal78ACtGTc?si=ePI6MMzAIPLpG6OX">&ldquo;What&rsquo;s Next for AI Agentic Workflows&rdquo;</a></em> and <em><a href="https://youtu.be/q1XFm21I-VQ?si=uq5e8Z_ZarzdlDrJ">&ldquo;Andrew Ng on AI Agentic Workflows and Their Potential for Driving AI Progress&rdquo;</a></em>, that agentic workflows are inherently more iterative than current LLM-based agents, which typically operate on a zero-shot basis. This iterative nature allows agentic AI to achieve significantly better outcomes. For instance, while zero-shot GPT-3.5 achieved a 48% success rate on the HumanEval coding benchmark, and zero-shot GPT-4 improved to 67.6%, multi-agent AI systems like AutoDev and AgentCoder achieved significantly higher success rates, reaching 91.5% and 96.3%, respectively. This stark contrast highlights the potential of agentic AI to surpass the capabilities of traditional models.</p>
<h3 id="vision-agent-an-open-source-agentic-ai-from-landing-ai">Vision Agent: An Open Source Agentic AI from Landing AI</h3>
<p>One of the practical implementations of agentic AI is the <em><a href="https://github.com/landing-ai/vision-agent">Vision Agent</a></em>, an open-source project developed by Andrew Ng and his team at <a href="https://landing.ai">Landing AI</a>. This agentic AI system is designed to specialise in computer vision tasks, enabling different AI agents to collaborate on complex visual processing tasks, such as object detection, image classification, and anomaly detection.</p>
<p>The Vision Agent framework allows for the modular combination of AI agents, each focusing on a specific aspect of the task. For example, one agent might specialise in edge detection, while another focuses on object classification. By allowing these agents to work together, Vision Agent can deliver more accurate and robust results than a single AI model working alone. The framework&rsquo;s open-source nature also makes it accessible for developers and researchers, encouraging collaboration and further innovation in the field of agentic AI.</p>
<h3 id="metagpt-a-multi-agent-framework">MetaGPT: A Multi-Agent Framework</h3>
<p><em><a href="https://www.deepwisdom.ai">MetaGPT</a></em> is discussed in the paper <em><a href="https://arxiv.org/abs/2402.18679">&ldquo;Data Interpreter: An LLM Agent For Data Science&rdquo;</a></em> by Hong et al. This multi-agent collaborative framework is designed for software development, simulating the software development lifecycle by leveraging multiple AI agents, each specialising in a particular role, such as project management, code writing, and testing. This approach emulates a human software development team, where various specialists collaborate to complete a project effectively.</p>
<p>However, like many multi-agent systems, MetaGPT encounters challenges related to coordinating multiple agents and managing communication overhead. Despite these challenges, MetaGPT illustrates the potential of agentic AI to mirror and enhance human-like collaboration in software development.</p>
<h3 id="agentcoder-multi-agent-code-generation">AgentCoder: Multi-Agent Code Generation</h3>
<p><em><a href="https://github.com/huangd1999/AgentCoder">AgentCoder</a></em>, presented in the paper <em><a href="https://arxiv.org/abs/2312.13010">&ldquo;AgentCoder: Multi-Agent-based Code Generation with Iterative Testing and Optimisation&rdquo;</a></em> by Huang et al., represents another significant advancement in agentic AI. This system is designed specifically for multi-agent code generation, incorporating effective testing and self-optimisation mechanisms. AgentCoder uses a team of AI agents to not only generate code but also to iteratively test and optimize it, ensuring higher quality and efficiency in the code produced.</p>
<p>In evaluations, AgentCoder demonstrated exceptional performance, achieving 95% success on the HumanEval benchmark by leveraging the strengths of multiple specialised agents working together. This success underscores the promise of agentic AI in enhancing the software development process, from code generation to testing and optimisation.</p>
<h3 id="autodev-automated-ai-driven-development">AutoDev: Automated AI-Driven Development</h3>
<p>Microsoft&rsquo;s <em>AutoDev</em> is another cutting-edge framework that exemplifies the potential of agentic AI. As described in the paper <em><a href="https://arxiv.org/abs/2403.08299">&ldquo;AutoDev: Automated AI-Driven Development&rdquo;</a></em> by Tufano et al., AutoDev is designed to fully automate software engineering tasks. It enables AI agents to autonomously perform a wide range of operations within a codebase, including file editing, building, testing, and git operations, all within a secure, user-controlled environment. The framework&rsquo;s effectiveness was demonstrated on the HumanEval dataset, where it achieved a Pass@1 score of 91.5% for code generation and 87.8% for test generation.</p>
<p>AutoDev goes beyond simple code suggestions, integrating deeply with the development environment to manage tasks that typically require significant human intervention. Its ability to handle complex, multi-step tasks autonomously marks a significant leap forward in the capabilities of AI-driven development tools.</p>
<h3 id="why-agentic-ai-matters">Why Agentic AI Matters</h3>
<p>The implications of agentic AI are profound, extending far beyond a single industry. If we can truly harness the potential of agentic AI, the automation of many jobs may be closer than we realise. These AI systems, capable of handling interconnected tasks across various domains, could lead to significant shifts in how work is structured and executed. By distributing tasks among specialised agents, entire workflows could be automated, potentially reducing the need for human intervention in areas that were once considered too complex for AI to manage.</p>
<p>In software engineering, this evolution shifts the focus from human-led coding to human-led prompting. As agentic AI systems take on more of the actual coding, testing, and reviewing, the role of engineers may pivot toward describing requirements in precise, effective ways to guide these AI agents. This change underscores the importance of developing strong skills in articulating and refining prompts - prompt engineering - as the ability to communicate effectively with AI will become increasingly critical in this new paradigm.</p>
<h3 id="looking-ahead">Looking Ahead</h3>
<p>The journey toward fully realising the potential of agentic AI is just beginning. The advancement of frameworks like Auto-GPT, AutoDev, AgentCoder and MetaGPT represents a significant step forward in this direction. As we continue to develop and refine these technologies, we&rsquo;re likely to see even more transformative impacts on the way we approach software engineering.</p>
]]><![CDATA[<hr><p>Thanks for reading this post via RSS! üëã</p>]]><![CDATA[<a href="mailto:annie.luxton@gmail.com?subject=Is Agentic AI the Key to Automating Human Work?">Reply to this post by email</a>]]></description>
    </item>
    <item>
      <title>Deming‚Äôs Wisdom for Staff&#43; Engineers: A Recap of My Talk at StaffPlus London 2024</title>
      <link>http://annievella.com/posts/demings-wisdom-for-staff-plus-engineers/</link>
      <pubDate>Sun, 25 Aug 2024 09:00:00 +1200</pubDate><author>annie.luxton@gmail.com (Annie Vella)</author>
      <guid>http://annievella.com/posts/demings-wisdom-for-staff-plus-engineers/</guid>
      <description>
      
      
      <![CDATA[<p>In June 2024, I had the privilege of travelling from Auckland, New Zealand, to speak at <strong>StaffPlus London</strong> - an unforgettable experience. Speaking at such a high-profile event, surrounded by so many talented Staff+ Engineers, was truly special. What made this event particularly memorable wasn&rsquo;t just the prominence of the event but the opportunity to share something that has become deeply important to me: how the timeless teachings of <strong>W. Edwards Deming</strong> remain as relevant today as ever in the constantly evolving world of technology.</p>
<p>Stepping into a Distinguished Engineer role last year pushed me to explore leadership in new ways. It was during this time that I discovered Deming‚Äôs work, which provided me with clarity and direction. His insights have shaped how I think about creating environments where engineers can thrive and continually improve.</p>
<figure class="center"><img src="http://annievella.com/images/staffplus-london-2024-deming.jpeg"
    alt="StaffPlus London 2024 - Deming&#39;s Wisdom for Staff&#43; Engineers"><figcaption>
      <p>StaffPlus London 2024 - Deming&rsquo;s Wisdom for Staff+ Engineers</p>
    </figcaption>
</figure>

<p>For those interested, my <a href="https://annievella.com/files/staffplus-london-june-2024-deming's-wisdom-for-staff-plus-engineers.pdf">slides from the talk are available here</a>, and you can find the <a href="https://leaddev.com/staffplus-london-2024/video/demings-wisdom-staff-engineers-modern-take-timeless-principles">video of the talk here</a>. It may still be paywalled, although I hope it will be accessible soon. In the meantime, below is a summary of the key points I covered during the talk.</p>
<h3 id="why-deming">Why Deming?</h3>
<p>W. Edwards Deming, known as the father of Total Quality Management, is best known for his work in post-war Japan, where his teachings on quality and systems thinking transformed industries. Deming wasn‚Äôt merely concerned with improving processes; his focus was on changing how we think and lead.</p>
<p>For me, discovering Deming‚Äôs work felt like finding a key piece of the leadership puzzle. His emphasis on continuous improvement and pride in workmanship deeply resonates with my own values. But what really struck me was how much Deming‚Äôs views on leadership aligned with what I had already believed. One of his quotes that I agree with wholeheartedly is, <em>‚ÄúTo manage one must lead. To lead, one must understand the work that he and his people are responsible for.‚Äù</em> This idea is central to effective leadership ‚Äì ensuring there is a deep understanding of the work happening across the organisation and the challenges engineers face. Curiosity plays a vital role here too. By staying curious, continuously asking questions, and exploring how things work, one is better equipped to provide the right guidance and support. Deming‚Äôs philosophy reinforced this, showing that leadership is about more than oversight; it‚Äôs about being in tune with the system, the people involved, and the processes that drive improvement.</p>
<h3 id="deming-to-devops">Deming to DevOps</h3>
<p>Deming‚Äôs influence can be traced through modern methodologies such as <strong>Toyota‚Äôs Production System (TPS)</strong>, <strong>Lean Manufacturing</strong>, <strong>Agile</strong>, and <strong>DevOps</strong>. His teachings laid the foundation for continuous improvement, reducing waste, and optimising processes, all of which are central tenets of Lean and Agile. In the software world, these principles evolved further into DevOps, where collaboration and system optimisation are critical for improving quality and speed.</p>
<h3 id="demings-system-of-profound-knowledge">Deming‚Äôs System of Profound Knowledge</h3>
<p>At the heart of Deming‚Äôs philosophy is his <em>System of Profound Knowledge</em>, which consists of four key areas:</p>
<ol>
<li><strong>Appreciation for a system</strong> ‚Äì Recognising that organisations are socio-technical systems, where nothing happens in isolation. Changing one part can have unintended consequences elsewhere, so we must optimise systems holistically.</li>
<li><strong>Knowledge about variation</strong> ‚Äì Distinguishing between common cause (inherent in the process) and special cause (due to external factors) variations is key. Common cause issues require systemic changes, which fall under management‚Äôs responsibility.</li>
<li><strong>Theory of knowledge</strong> ‚Äì Questioning why we know what we know, grounding actions in facts and context. Operational definitions ensure clarity and consistency in our understanding.</li>
<li><strong>Psychology</strong> ‚Äì Refers to the human aspects of work. Intrinsic motivators and purpose are essential for creating productive and enjoyable work environments.</li>
</ol>
<p>For Staff+ Engineers, these concepts are invaluable when tackling complex systems. Whether we are improving processes, enhancing collaboration, or driving innovation, Deming‚Äôs principles guide us toward a more holistic understanding of the challenges we face.</p>
<h3 id="demings-14-points-for-management">Deming‚Äôs 14 Points for Management</h3>
<p>Deming‚Äôs <em>14 Points for Management</em> serve as a practical guide for leaders striving to create better systems and environments. While all the points are valuable, a few stood out to me as especially relevant for Staff+ Engineers:</p>
<ol>
<li><strong>Remove barriers to pride in workmanship</strong> ‚Äì Empower engineers to take pride in their work by eliminating obstacles that hinder creativity and innovation. When people enjoy their work, it drives both personal satisfaction and organisational success.</li>
<li><strong>Drive out fear</strong> ‚Äì Build a culture where open communication is encouraged, and people feel safe raising issues without fear of blame. This is closely related to the modern concept of psychological safety, which is crucial for fostering innovation and a supportive work environment.</li>
<li><strong>Break down silos</strong> ‚Äì Promote collaboration across teams to ensure smoother workflows and better outcomes. When silos are broken down, organisations become more agile and effective.</li>
<li><strong>Institute training and self-improvement</strong> ‚Äì Continuous learning is essential, not just for individual growth but for the long-term success of teams. Investing in self-improvement helps teams adapt and thrive in an ever-changing landscape.</li>
</ol>
<h3 id="practical-applications-in-modern-software-engineering">Practical Applications in Modern Software Engineering</h3>
<p>Deming‚Äôs teachings are directly applicable to modern software engineering practices. In my talk, I explored three key areas where these principles can be applied today: <strong>Shift Left</strong>, <strong>Site Reliability Engineering (SRE)</strong>, and <strong>Developer Productivity</strong>.</p>
<h4 id="shift-left">Shift Left</h4>
<p>Shift Left involves moving security and quality testing earlier in the software development lifecycle to detect issues sooner and reduce costs. Deming‚Äôs <strong>appreciation for a system</strong> fits perfectly with this approach‚Äîby integrating quality into the development process from the start, we reduce the need for inspection and rework later on. As Deming said, <em>‚ÄúQuality does not just happen: it is built in.‚Äù</em> <strong>Adopting the new philosophy</strong> is also critical for embracing this shift, as it requires a mindset shift across the organisation. Everyone must be on board with the idea that quality is a shared responsibility, not something that can be <em>inspected</em> into a product, especially not at the end of the process. This mindset change helps ensure that quality is built in from the beginning rather than flung over the fence to dedicated test teams.</p>
<h4 id="site-reliability-engineering-sre">Site Reliability Engineering (SRE)</h4>
<p>SRE applies software engineering principles to IT operations, aiming to create scalable and reliable systems. Deming‚Äôs belief that <em>‚ÄúA bad system will beat a good person every time‚Äù</em> is particularly relevant to SRE. When incidents occur, it‚Äôs not about individual failures but about systems allowing those failures to happen. <strong>Knowledge about variation</strong> is key here‚Äîunderstanding the different types of variation (such as common cause vs. special cause) allows us to address system issues effectively and improve reliability. <strong>Theory of knowledge</strong> also plays a crucial role. In SRE, SLOs are operational definitions that help us to measure system performance through automated monitoring and alerting, allowing for data-driven insights. This approach ensures that we‚Äôre continuously learning and improving based on real data rather than assumptions.</p>
<h4 id="developer-productivity">Developer Productivity</h4>
<p>Improving developer productivity has become a major focus in modern engineering teams. As Deming said, <em>‚ÄúIt isn‚Äôt enough to do your best; you have to know what to do, and then do your best.‚Äù</em> This aligns with his <strong>theory of knowledge</strong>, which emphasises the need for data-driven decisions. To improve productivity, we need to measure the right things and understand them within the context of our systems. Additionally, <strong>psychology</strong> plays a critical role‚Äîfactors like job satisfaction, motivation, and psychological safety all directly impact productivity. By creating environments where developers feel valued and supported, we can significantly boost both productivity and morale.</p>
<h3 id="final-thoughts">Final Thoughts</h3>
<p>Speaking at StaffPlus London 2024 was one of the highlights of my year. Travelling from New Zealand to such a renowned event and sharing my insights alongside experienced technical leaders was an incredibly rewarding experience. I am so grateful for the opportunity to explore how Deming‚Äôs timeless teachings continue to resonate in our modern world and how they can help us lead more effectively as Staff+ Engineers.</p>
<p>Reflecting on my relatively recent journey with Deming‚Äôs work, I‚Äôm reminded of his unwavering belief in continuous improvement and the pursuit of knowledge. For those of you in Staff+ roles, I encourage you to embrace systems thinking, foster collaboration, and always keep learning. As Deming famously said, <em>‚ÄúLearning is not compulsory; it‚Äôs voluntary. Improvement is not compulsory; it‚Äôs voluntary. But to survive, we must learn.‚Äù</em></p>
]]><![CDATA[<hr><p>Thanks for reading this post via RSS! üëã</p>]]><![CDATA[<a href="mailto:annie.luxton@gmail.com?subject=Deming‚Äôs Wisdom for Staff+ Engineers: A Recap of My Talk at StaffPlus London 2024">Reply to this post by email</a>]]></description>
    </item>
    <item>
      <title>Exploring Systems Thinking Through Russell Ackoff</title>
      <link>http://annievella.com/posts/exploring-systems-thinking-through-russell-ackoff/</link>
      <pubDate>Sat, 06 Jul 2024 09:00:00 +1200</pubDate><author>annie.luxton@gmail.com (Annie Vella)</author>
      <guid>http://annievella.com/posts/exploring-systems-thinking-through-russell-ackoff/</guid>
      <description>
      
      
      <![CDATA[<p>Learning about Deming has led me to another incredible thinker - Russell Ackoff. Born in 1919, Ackoff is best known for his contributions to Systems Thinking.</p>
<p>In one of his lectures, <a href="https://youtu.be/yGN5DBpW93g">From Mechanistic to Systemic Thinking</a>, Ackoff discusses systems and the difference between analysis and synthesis. He explains that the essential properties of a system are unique to the system as a whole. These properties arise from the interactions between the parts of the system. In other words, a system is more than the sum of its parts; it is the product of their interactions.</p>
<p>At first glance, it might seem logical to understand a system by breaking it down into its individual parts and studying each part separately. This approach is called ‚Äòanalysis‚Äô - basically, divide and conquer. But when you take a system apart, it loses its essential properties - just like a steering wheel on its own can‚Äôt ‚Äòsteer‚Äô.</p>
<p>In the 1950s, it became clear that analysis alone couldn&rsquo;t fully explain a system. This led to the development of another method of thinking - synthesis. Instead of breaking a system down into parts, synthesis looks at the system within the context of the larger system it operates in and tries to understand its role within that larger system.</p>
<figure class="center"><img src="http://annievella.com/images/systems-thinking-analysis-vs-synthesis.png"
    alt="Analysis vs Synthesis"><figcaption>
      <p>Analysis vs Synthesis</p>
    </figcaption>
</figure>

<p>Ackoff explains that analysis produces &ldquo;know-how,&rdquo; or knowledge - like instructions. However, knowledge alone doesn‚Äôt equal understanding. Understanding comes from explanations, which tell us why things work the way they do. Synthetic thinking helps us understand the role or function of a system within a larger system, providing deeper insights.</p>
<p>Ackoff‚Äôs insights emphasise that to truly understand and improve systems, we must consider both their individual components and their roles within larger systems. This holistic approach, known as Systems Thinking, is essential for driving meaningful change and innovation.</p>
<p><strong>Key Insights:</strong></p>
<ul>
<li>The essential properties of a system belong to the interactions between the parts, not to the parts themselves.</li>
<li>These properties are lost when a system is taken apart.</li>
<li>Analysis involves breaking a system into parts to understand how it works, yielding knowledge.</li>
<li>Synthesis involves viewing a system as part of a larger system to understand why it works, yielding understanding.</li>
<li>Explanation always lies outside the system.</li>
<li>Systems Thinking fuses analysis and synthesis, depending on whether we seek knowledge or understanding.</li>
</ul>
<p>Almost everything can be thought of as a system, making it fascinating to learn about different approaches to understanding them. I‚Äôm thoroughly enjoying this learning journey, inspired by pioneering thinkers like Russell Ackoff and W. Edwards Deming.</p>
]]><![CDATA[<hr><p>Thanks for reading this post via RSS! üëã</p>]]><![CDATA[<a href="mailto:annie.luxton@gmail.com?subject=Exploring Systems Thinking Through Russell Ackoff">Reply to this post by email</a>]]></description>
    </item>
  </channel>
</rss>
