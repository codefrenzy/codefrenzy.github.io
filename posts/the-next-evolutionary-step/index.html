<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <title>The Next Evolutionary Step - Annie Vella</title>
  <meta property="og:title" content="The Next Evolutionary Step - Annie Vella" />
  <meta name="twitter:title" content="The Next Evolutionary Step - Annie Vella" />
  <meta name="description" content="The recent releases of Claude Code and OpenAI Codex caught my attention, but not for the reasons you might expect. I was puzzled by the enthusiasm they&rsquo;ve generated. These are, after all, terminal tools. In an era where graphical IDEs dominate, with tools like Cursor, Windsurf, and VSCode evolving toward ever-more seamless integrations, like &lsquo;Design Mode&rsquo;, why are we getting excited about terminal-based AI coding tools that feel like a step backwards?">
  <meta property="og:description" content="The recent releases of Claude Code and OpenAI Codex caught my attention, but not for the reasons you might expect. I was puzzled by the enthusiasm they&rsquo;ve generated. These are, after all, terminal tools. In an era where graphical IDEs dominate, with tools like Cursor, Windsurf, and VSCode evolving toward ever-more seamless integrations, like &lsquo;Design Mode&rsquo;, why are we getting excited about terminal-based AI coding tools that feel like a step backwards?">
  <meta name="twitter:description" content="The recent releases of Claude Code and OpenAI Codex caught my attention, but not for the reasons you might expect. I was puzzled by the enthusiasm they&rsquo;ve generated. These are, after all, â€¦">
  <meta name="author" content="Annie Vella"/>
  <meta property="og:site_name" content="Annie Vella" />
  <meta property="og:url" content="http://annievella.com/posts/the-next-evolutionary-step/" />
  <meta property="og:type" content="article" />
  <meta name="twitter:card" content="summary" />
  <meta name="generator" content="Hugo 0.140.1">
  <link rel="stylesheet" href="/css/style.css" media="all" />

  <link rel="stylesheet" href="/css/syntax.css" media="all" />
  <link rel="stylesheet" href="/css/custom.css" media="all" />

  <script src="/js/script.js"></script>
  <script src="/js/custom.js"></script>
  <script defer src="/fontawesome/all.min.js"></script>
</head>

<body>

<header class="site-header">
  <nav class="site-navi">
    <h1 class="site-title"><a href="/">Annie Vella</a></h1>
    <ul class="site-navi-items">
      <li class="site-navi-item-resources"><a href="/resources/" title="Resources">Resources</a></li>
      <li class="site-navi-item-speaking"><a href="/speaking/" title="Speaking">Speaking</a></li>
      <li class="site-navi-item-about"><a href="/about/" title="About">About</a></li>
    </ul>
  </nav>
</header>
<hr class="site-header-bottom">

  <div class="main" role="main">
    <article class="article">
      
      
      <h1 class="article-title">The Next Evolutionary Step</h1>
      
      <hr class="article-title-bottom">
      <ul class="article-meta">
        
        <li class="article-meta-date"><time>May 9, 2025</time></li>
        
      </ul>
      
      <p>The recent releases of Claude Code and OpenAI Codex caught my attention, but not for the reasons you might expect. I was puzzled by the enthusiasm they&rsquo;ve generated. These are, after all, terminal tools. In an era where graphical IDEs dominate, with tools like Cursor, Windsurf, and VSCode evolving toward ever-more seamless integrations, like &lsquo;<a href="https://www.linkedin.com/posts/tomkrcha_introducing-design-mode-for-cursor-activity-7325527044459524096-tqy7">Design Mode</a>&rsquo;, why are we getting excited about terminal-based AI coding tools that feel like a step backwards?</p>
<figure class="center"><img src="/images/questprobe-featuring-spider-man.png"
    alt="Questprobe Featuring Spider-Man (1984)"><figcaption>
      <p><a href="https://youtu.be/bw6KY5XaF9M?si=Sbw74N5UA71Ad27K">Questprobe Featuring Spider-Man (1984)</a></p>
    </figcaption>
</figure>

<p>This is what comes to mind when I think of a natural-language-based CLI - an old Commodore 64 text adventure game that I used to play as a kid.</p>
<p>A move back to the basics seems odd but intriguing, so I decided to give them a try and see if I could figure out what all the fuss was about.</p>
<h2 id="claude-code">Claude Code</h2>
<p>Setting it up was a breeze. Just follow the instructions <a href="https://docs.anthropic.com/en/docs/claude-code/overview">here</a> and you&rsquo;ll be up and running in no time.</p>
<p>You&rsquo;ll need an Anthropic account because you need some money on your account before you can use Claude Code. I gave mine $5 USD and it was enough to build a couple of simple apps.</p>
<p>In a weird way, it feels like I&rsquo;m <em>playing</em> Questprobe Featuring Spider-Man but instead of asking it to go north, I&rsquo;m asking it to write me an app.</p>
<figure class="center"><img src="/images/building-spider-man-2025.png"
    alt="Claude Code - Building Spider-Man"><figcaption>
      <p>Claude Code - Building Spider-Man</p>
    </figcaption>
</figure>

<p>From the simple prompt, <em>&ldquo;Can you create a web-based version of the text adventure game called Questprobe Featuring Spider-Man from 1984 - <a href="https://www.squakenet.com/game/questprobe-featuring-spider-man/">https://www.squakenet.com/game/questprobe-featuring-spider-man/</a> ?&rdquo;</em>, Claude Code generated a basic but functional web-based version of Questprobe Featuring Spider-Man in less than a minute.</p>
<figure class="center"><img src="/images/spider-man-2025.png"
    alt="Claude Code Spider-Man"><figcaption>
      <p>Claude Code Spider-Man</p>
    </figcaption>
</figure>

<p>I really appreciated how it created a plan and then systematically ticked off each step, all from such a simple prompt. By default, it stops and asks you to confirm each significant step - but it also gives you the option to confirm and &ldquo;not ask again this session&rdquo;.</p>
<p>Well hello dear friend, <em>vigilance decrement</em>. I knew you&rsquo;d show up sooner or later.</p>
<p>It&rsquo;s far too enticing to select that option. After all, how much reviewing are you <em>really</em> doing in the terminal window? This reminds me of something I&rsquo;ve noticed about code reviews throughout my career - they&rsquo;re one of those activities that engineers know are valuable (especially for learning about the codebase and seeing how others solve problems), but rarely enjoy doing. In most teams, you&rsquo;ll find engineers having to repeatedly ask - sometimes even beg - their colleagues to review their code. It&rsquo;s not surprising really; we engineers love <em>creating</em> things, and reviewing someone else&rsquo;s code feels about as far from creation as writing tests does. Both are essential for quality, but they don&rsquo;t scratch that builder&rsquo;s itch.</p>
<h2 id="openai-codex">OpenAI Codex</h2>
<p>Setting it up is straightforward - just follow the instructions <a href="https://github.com/openai/codex">here</a>. As with Claude Code, you&rsquo;ll need an OpenAI account with some credit before you can use it.</p>
<p>I asked Codex to analyse a really old side project of mine - an iPad game called <em>Easter Egg Hunt</em> written in Objective-C back in 2013 or so. The prompt was simple: <em>&ldquo;Can you describe the purpose of the app?&rdquo;</em></p>
<figure class="center"><img src="/images/openai-codex-easterhunt.png"
    alt="OpenAI Codex Easter Egg Hunt Description"><figcaption>
      <p>OpenAI Codex Easter Egg Hunt Description</p>
    </figcaption>
</figure>

<p>Within seconds, it produced a remarkably accurate description of the app - from the three themed environments (Garden, Beach, or Snow) to the core gameplay of eggs periodically &ldquo;popping&rdquo; up in random locations. It even caught implementation details like the particle effects and chimes every five eggs, the in-app purchase system for unlocking scenes, and the use of Localytics for analytics. All this without ever seeing the app running or having any screenshots - just pure code comprehension.</p>
<p>Encouraged, I pushed a little further. <em>&ldquo;Draw some high-value diagrams using Mermaid that would help a new engineer understand this codebase.&rdquo;</em></p>
<p>The results were genuinely impressive. Codex generated a series of clear, thoughtful visuals - from class relationship diagrams showing the core game structure to sequence diagrams illustrating the gameplay flow. These diagrams captured relationships that would take hours for a human to extract from unfamiliar code.</p>
<figure class="center"><img src="/images/openai-codex-easterhunt-class-diagram.png"
    alt="OpenAI Codex Easter Egg Hunt Class Diagram"><figcaption>
      <p>OpenAI Codex Easter Egg Hunt Class Diagram</p>
    </figcaption>
</figure>

<figure class="center"><img src="/images/openai-codex-easterhunt-sequence-diagram.png"
    alt="OpenAI Codex Easter Egg Hunt Sequence Diagram"><figcaption>
      <p>OpenAI Codex Easter Egg Hunt Sequence Diagram</p>
    </figcaption>
</figure>

<p>Think about onboarding - in minutes, a new engineer could understand a codebase that would normally take days to unravel.</p>
<p>While these CLI tools might seem like a step backward, I was starting to see glimpses of something more interesting emerging.</p>
<h2 id="beyond-the-terminal-interface">Beyond The Terminal Interface</h2>
<p>For developers used to modern IDEs, returning to the terminal might feel like a blast from the past. But focusing on the interface misses something crucial.</p>
<p>These tools aren&rsquo;t here to replace our IDEs - they represent the next natural evolutionary step in development. A step where AI intelligence can be embedded throughout our entire workflow.</p>
<p>Both OpenAI Codex and Claude Code can run in <em>headless mode</em>, allowing them to be integrated into pipelines, scheduled tasks, and automated testing suites. Claude Code offers a <a href="https://docs.anthropic.com/en/docs/claude-code/cli-usage#print-mode-details">non-interactive mode</a> designed for programmatic use. OpenAI Codex similarly supports a <a href="https://github.com/openai/codex#non-interactive--ci-mode">non-interactive / CI mode</a> for use in pipelines.</p>
<figure class="center"><img src="/images/openai-codex-non-interactive-mode.png"
    alt="OpenAI Codex Non-Interactive Mode"><figcaption>
      <p>OpenAI Codex Non-Interactive Mode</p>
    </figcaption>
</figure>

<p>This capability transforms these AI assistants from mere copilots into programmable units of intelligence that can be woven seamlessly into our larger systems. The implications of this shift are significant.</p>
<p>Imagine this:</p>
<ul>
<li>After your build, test and deploy steps, get Claude Code to generate a series of diagrams for your codebase which it can then safely stash away in your documentation repository as a snapshot-in-time.</li>
<li>You know those pesky flaky tests that keep causing your pipeline to break but aren&rsquo;t always easy to fix (even if you did have time to look at them)? Why not get OpenAI Codex to help you fix them automatically?</li>
<li>It could perform a <em>pre-post-mortem</em> analysis - evaluating the combined impact of changes and assessing risks across all dimensions (operational incidents, security vulnerabilities, change reversibility) before they become real problems.</li>
</ul>
<p>What we&rsquo;re seeing is just the beginning. Think about all the repetitive, time-consuming steps in our development lifecycle - both inner loop activities like coding and outer loop activities like reviews and documentation. These tools are opening up possibilities to automate not just the coding itself, but also those friction-heavy outer loop activities that often slow us down. As <a href="https://abinoda.com">Adi Noda</a>, CEO and cofounder of DX, recently said in a Gartner Podcast that was asking the question <em><a href="https://open.spotify.com/episode/3W2VCLGTI31is9AFbgDhGr?si=eaca8a061feb4e24">Does Developer Experience Really Matter?</a></em>:</p>
<blockquote>
<p>We tend to see more outer loop friction points than inner loop. So code reviews, CI, and release processes tend to surface as greater areas of friction than the inner loop.</p>
</blockquote>
<p>We now have the tools to address these outer loop friction points, automating away the steps we know add value but don&rsquo;t enjoy doing. While these tools are still relatively simple, they represent a natural evolution in the AI-driven development era - one that unlocks opportunities far beyond just writing code.</p>
<h2 id="final-thoughts">Final Thoughts</h2>
<p>When I first encountered these terminal-based tools, I couldn&rsquo;t help but wonder if we were taking a step backward. But that initial reaction missed something important: this isn&rsquo;t about the interface - it&rsquo;s about programmability.</p>
<p>Just as git&rsquo;s command-line interface enabled countless automation workflows, these AI assistants can be invoked programmatically to work silently in the background - from reviewing code to generating documentation to managing releases.</p>
<p>This is how evolution often works - not in dramatic leaps, but in subtle shifts that fundamentally change how we work. Software engineering isn&rsquo;t <em>dead</em>, but it is changing. The next step is yours to take: look at your development workflow, identify the friction points, and consider how to weave these capabilities into your pipeline.</p>

    </article>

    


    
    <ul class="pager article-pager">
      <li class="pager-newer pager-noitem">&lt; Newer</li>
      <li class="pager-older">
        <a href="/posts/you-cant-prompt-your-way-to-intuition/" data-toggle="tooltip" data-placement="top" title="You Canâ€™t Prompt Your Way to Intuition">Older &gt;</a>
      </li>
    </ul>
    
  </div>


<div class="site-footer">
  <div class="copyright">Â© Copyright 2025 Annie Vella</div>
  <ul class="site-footer-items">
    <li class="site-footer-item-about"><a href="/about/" title="About">About</a></li>
  </ul>
  <div class="powerdby">
    Powered by <a href="https://gohugo.io/">Hugo</a> and <a href="https://github.com/taikii/whiteplain">Whiteplain</a>
  </div>
</div>

      <script async src="https://www.googletagmanager.com/gtag/js?id=G-STYW83D479"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-STYW83D479');
        }
      </script>

</body>
</html>
